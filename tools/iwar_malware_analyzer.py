#!/usr/bin/env python3
"""
IWAR Malware Analyzer - Comprehensive PDF/Binary Threat Analysis
================================================================
Blue Team analysis tool for detecting and analyzing sophisticated malware

Based on methods described in:
- IWAR_CVE_CORRELATION_MATRIX.md
- IWAR_COMPREHENSIVE_UNCERTAINTY_ANALYSIS.md
- IWAR_CVE_THREAT_INTELLIGENCE_REPORT.md
- IWAR_SCAN_REPORT.md

Capabilities:
- PE executable extraction and analysis
- LSB steganography detection in images
- Entropy analysis for encryption detection
- Compression ratio analysis
- CVE correlation and pattern matching
- Malware family attribution (OceanLotus, Epic Turla, IcedID, etc.)
- JPEG/image analysis
- PDF structure analysis
- Base64 payload detection
- IOC extraction

DEFENSIVE SECURITY USE ONLY
Author: SWORDIntel
Date: 2025-11-16
"""

import os
import sys
import struct
import math
import hashlib
import base64
import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import json

try:
    from PIL import Image
    import numpy as np
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    np = None  # Define np as None when not available


@dataclass
class ThreatIndicator:
    """Represents a single threat indicator"""
    name: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    confidence: int  # 0-100
    description: str
    evidence: List[str]
    related_cves: List[str] = None
    iocs: List[str] = None


@dataclass
class MalwareAttribution:
    """Malware family attribution result"""
    family_name: str
    confidence: int  # 0-100
    matching_ttps: List[str]
    description: str
    references: List[str]


class IWARMalwareAnalyzer:
    """Comprehensive malware analysis framework"""

    def __init__(self, verbose=False):
        """Initialize IWAR analyzer"""
        self.verbose = verbose
        self.indicators = []
        self.attributions = []
        self.file_data = None
        self.file_path = None
        self.file_entropy = 0.0
        self.pe_candidates = []
        self.lsb_data = []
        self.suspicious_compressions = []
        self.base64_strings = []

        # CVE database from IWAR reports
        self.cve_database = self._load_cve_database()
        self.malware_families = self._load_malware_families()

    def _load_cve_database(self) -> Dict[str, Dict]:
        """Load CVE database from IWAR threat intelligence"""
        return {
            # Embedded PE Executables
            'CVE-2010-1240': {
                'severity': 7.5,
                'type': 'Embedded PE EXE in PDF',
                'attack_vectors': ['pe_executable', 'pdf_embedding'],
                'confidence_match': 100,
                'malware': ['Metasploit', 'DarkCloud'],
                'description': 'PDF embedded EXE exploitation'
            },
            'CVE-2018-8414': {
                'severity': 7.8,
                'type': 'Multi-stage PE extraction',
                'attack_vectors': ['multi_stage', 'pe_extraction', 'settingcontent_ms'],
                'confidence_match': 85,
                'malware': ['Multi-stage Windows exploits'],
                'description': 'Windows Shell SettingContent-ms RCE'
            },

            # JPEG/Image Steganography
            'CVE-2009-0927': {
                'severity': 9.3,
                'type': 'JPEG steganography carrier',
                'attack_vectors': ['lsb_steganography', 'jpeg_exploitation'],
                'confidence_match': 95,
                'malware': ['BlackHole EK', 'OceanLotus'],
                'description': 'JPEG memory corruption vector'
            },
            'CVE-2009-0658': {
                'severity': 9.3,
                'type': 'JBIG2 double encoding',
                'attack_vectors': ['jbig2_exploitation', 'double_encoding'],
                'confidence_match': 85,
                'malware': ['Secureworks documented'],
                'description': 'JBIG2 buffer overflow'
            },
            'CVE-2009-1858': {
                'severity': 9.3,
                'type': 'JBIG2 filter memory',
                'attack_vectors': ['jbig2_filter', 'memory_corruption'],
                'confidence_match': 85,
                'malware': ['IBM X-Force documented'],
                'description': 'JBIG2 filter memory corruption'
            },

            # Compression/Encoding
            'CVE-2016-4265': {
                'severity': 6.5,
                'type': 'FlateDecode OOB',
                'attack_vectors': ['extreme_compression', 'flatedecode'],
                'confidence_match': 75,
                'malware': ['Compression variant'],
                'description': 'FlateDecode out-of-bounds'
            },
            'CVE-2011-2462': {
                'severity': 10.0,
                'type': 'U3D multi-layer encoding',
                'attack_vectors': ['multi_layer_encoding', 'base64', 'flatedecode'],
                'confidence_match': 85,
                'malware': ['PoC exploits'],
                'description': 'U3D component zero-day'
            },

            # High Entropy/Encryption
            'CVE-2010-2883': {
                'severity': 9.3,
                'type': 'Embedded font exploitation',
                'attack_vectors': ['embedded_font', 'truetype', 'high_entropy'],
                'confidence_match': 85,
                'malware': ['BlackHole EK', 'Cool EK'],
                'description': 'CoolType.dll TrueType font overflow'
            },
            'CVE-2023-26369': {
                'severity': 7.8,
                'type': 'TTF font RCE (zero-day)',
                'attack_vectors': ['ttf_font', 'obfuscated_ttf', 'high_entropy'],
                'confidence_match': 75,
                'malware': ['North Korean APT'],
                'description': 'Adobe Acrobat TTF font processing'
            },

            # Multi-stage Delivery
            'CVE-2013-2729': {
                'severity': 9.8,
                'type': 'Multi-stage PDF exploit',
                'attack_vectors': ['multi_stage', 'pdf_malware', 'memory_corruption'],
                'confidence_match': 90,
                'malware': ['Epic Turla (400+ infections)'],
                'description': 'Adobe Acrobat Reader numeric error'
            },

            # Base64/JavaScript
            'CVE-2023-21608': {
                'severity': 7.8,
                'type': 'JavaScript resetForm',
                'attack_vectors': ['javascript', 'pdf_js'],
                'confidence_match': 60,
                'malware': ['Public PoC available'],
                'description': 'Adobe Acrobat Reader resetForm RCE'
            },

            # Additional Critical CVEs
            'CVE-2010-0188': {
                'severity': 9.3,
                'type': 'Embedded TIFF base64',
                'attack_vectors': ['tiff_embedding', 'base64_encoding'],
                'confidence_match': 80,
                'malware': ['BlackHole EK'],
                'description': 'Adobe Reader TIFF image integer overflow'
            },
        }

    def _load_malware_families(self) -> Dict[str, Dict]:
        """Load malware family signatures"""
        return {
            'OceanLotus/APT32': {
                'origin': 'Vietnam-linked APT group',
                'confidence_threshold': 75,
                'ttps': [
                    'LSB steganography in PNG/JPEG',
                    'AES128 encrypted payloads',
                    'Multi-stage delivery',
                    'High entropy encrypted data',
                    'Government/diplomatic targeting'
                ],
                'indicators': {
                    'lsb_steganography': 100,
                    'aes_encryption': 100,
                    'multi_stage': 100,
                    'high_entropy': 95,
                    'jpeg_carrier': 90
                },
                'references': ['BlackBerry Cylance OceanLotus Steganography Analysis']
            },
            'Epic Turla': {
                'origin': 'Russia-linked APT group',
                'confidence_threshold': 70,
                'ttps': [
                    'PDF malware delivery',
                    'Multi-stage infection',
                    'Government-level targets',
                    'CVE-2013-2729 exploitation',
                    '400+ infections in 45+ countries'
                ],
                'indicators': {
                    'pdf_malware': 100,
                    'multi_stage': 100,
                    'government_targeting': 90,
                    'high_sophistication': 100
                },
                'references': ['Microsoft Threat Intelligence', 'NVD CVE-2013-2729']
            },
            'IcedID/BokBot': {
                'origin': 'Banking Trojan / Stegomalware',
                'confidence_threshold': 65,
                'ttps': [
                    'LSB steganography in PNG/JPEG',
                    'Payload embedded in images',
                    'Configuration files via steganography',
                    'High entropy payloads'
                ],
                'indicators': {
                    'lsb_steganography': 85,
                    'png_carrier': 90,
                    'jpeg_carrier': 80,
                    'high_entropy': 85
                },
                'references': ['Malwarebytes ThreatDown Analysis']
            },
            'DarkCloud Stealer': {
                'origin': 'Malware stealer campaign',
                'confidence_threshold': 60,
                'ttps': [
                    'PDF initial delivery',
                    'Multi-stage encrypted payload',
                    'XOR encryption obfuscation',
                    'Encrypted PE executables'
                ],
                'indicators': {
                    'pdf_delivery': 100,
                    'multi_stage': 90,
                    'xor_encryption': 85,
                    'pe_executable': 90
                },
                'references': ['Palo Alto Networks Unit42']
            },
            'Winos4.0': {
                'origin': 'Windows-targeting malware',
                'confidence_threshold': 55,
                'ttps': [
                    'PDF malware delivery',
                    'Multi-stage payload deployment',
                    'Encrypted shellcode',
                    'Anti-forensic techniques'
                ],
                'indicators': {
                    'pdf_delivery': 70,
                    'multi_stage': 70,
                    'encrypted_shellcode': 75,
                    'anti_forensic': 65
                },
                'references': ['GBHackers Winos4.0 Analysis']
            }
        }

    def analyze_file(self, file_path: str) -> Dict[str, Any]:
        """
        Comprehensive file analysis

        Args:
            file_path: Path to file to analyze

        Returns:
            Complete analysis report
        """
        self.file_path = file_path

        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File not found: {file_path}")

        # Read file data
        with open(file_path, 'rb') as f:
            self.file_data = f.read()

        if self.verbose:
            print(f"[*] Analyzing file: {file_path}")
            print(f"[*] Size: {len(self.file_data):,} bytes")

        # Reset indicators
        self.indicators = []
        self.attributions = []
        self.pe_candidates = []
        self.lsb_data = []
        self.suspicious_compressions = []
        self.base64_strings = []

        # Run all analysis methods
        self._analyze_entropy()
        self._detect_pe_executables()
        self._detect_base64_strings()
        self._analyze_file_structure()

        # PDF-specific analysis
        if self.file_data[:4] == b'%PDF':
            self._analyze_pdf_structure()

        # Image analysis (if PIL available)
        if PIL_AVAILABLE:
            self._extract_and_analyze_images()

        # CVE correlation
        self._correlate_cves()

        # Malware family attribution
        self._attribute_malware_family()

        # Generate report
        report = self._generate_report()

        return report

    def _analyze_entropy(self):
        """Calculate file entropy (encryption/compression indicator)"""
        if len(self.file_data) == 0:
            self.file_entropy = 0.0
            return

        # Calculate byte frequency
        byte_counts = [0] * 256
        for byte in self.file_data:
            byte_counts[byte] += 1

        # Calculate Shannon entropy
        entropy = 0.0
        for count in byte_counts:
            if count > 0:
                probability = count / len(self.file_data)
                entropy -= probability * math.log2(probability)

        self.file_entropy = entropy

        if self.verbose:
            print(f"[*] File entropy: {entropy:.4f} bits/byte")

        # High entropy indicator
        if entropy > 7.5:
            self.indicators.append(ThreatIndicator(
                name='High File Entropy',
                severity='HIGH',
                confidence=90,
                description=f'Entropy {entropy:.4f} indicates encryption or heavy compression',
                evidence=[
                    f'File entropy: {entropy:.4f} bits/byte',
                    'Threshold: 7.5+ (encryption indicator)',
                    'Similar to OceanLotus AES128 signature'
                ],
                related_cves=['CVE-2010-2883', 'CVE-2023-26369']
            ))

    def _detect_pe_executables(self):
        """Detect embedded PE executables"""
        # Search for MZ signatures
        offset = 0
        while True:
            offset = self.file_data.find(b'MZ', offset)
            if offset == -1:
                break

            # Extract PE candidate
            if offset + 64 <= len(self.file_data):
                pe_data = self.file_data[offset:offset+5000]  # Extract up to 5KB

                # Calculate entropy of PE candidate
                pe_entropy = self._calculate_chunk_entropy(pe_data)

                # Check for DOS header
                if len(pe_data) >= 64:
                    pe_offset_ptr = struct.unpack('<I', pe_data[60:64])[0]

                    self.pe_candidates.append({
                        'offset': offset,
                        'entropy': pe_entropy,
                        'pe_offset_ptr': pe_offset_ptr,
                        'data': pe_data
                    })

                    if self.verbose:
                        print(f"[!] PE signature found at offset {offset} (0x{offset:x})")
                        print(f"    Entropy: {pe_entropy:.4f} bits/byte")
                        print(f"    PE offset pointer: 0x{pe_offset_ptr:x}")

            offset += 1

        # Add indicators for PE candidates
        if self.pe_candidates:
            for i, pe in enumerate(self.pe_candidates, 1):
                severity = 'CRITICAL' if pe['entropy'] > 7.0 else 'HIGH'
                confidence = 100 if pe['entropy'] > 7.0 else 80

                self.indicators.append(ThreatIndicator(
                    name=f'Embedded PE Executable #{i}',
                    severity=severity,
                    confidence=confidence,
                    description='PE executable signature detected with high entropy (encrypted/obfuscated)',
                    evidence=[
                        f'Offset: {pe["offset"]:,} (0x{pe["offset"]:x})',
                        f'Entropy: {pe["entropy"]:.4f} bits/byte',
                        f'PE offset pointer: 0x{pe["pe_offset_ptr"]:x}',
                        'High entropy suggests encryption'
                    ],
                    related_cves=['CVE-2010-1240', 'CVE-2018-8414', 'CVE-2010-2883']
                ))

    def _detect_base64_strings(self):
        """Detect base64 encoded strings"""
        # Regex for base64 (at least 20 chars)
        base64_pattern = rb'[A-Za-z0-9+/]{20,}={0,2}'
        matches = re.finditer(base64_pattern, self.file_data)

        for match in matches:
            b64_str = match.group()
            try:
                decoded = base64.b64decode(b64_str)
                # Verify it's valid base64
                if base64.b64encode(decoded) == b64_str:
                    self.base64_strings.append({
                        'offset': match.start(),
                        'encoded': b64_str[:50],  # First 50 bytes
                        'decoded': decoded[:50],
                        'length': len(b64_str)
                    })
            except:
                pass

        if self.base64_strings:
            if self.verbose:
                print(f"[*] Found {len(self.base64_strings)} base64 encoded strings")

            self.indicators.append(ThreatIndicator(
                name='Base64 Encoded Strings',
                severity='MEDIUM',
                confidence=70,
                description=f'{len(self.base64_strings)} base64 strings detected (payload obfuscation)',
                evidence=[
                    f'Count: {len(self.base64_strings)} strings',
                    'Typical for payload encoding',
                    'Often used to bypass AV detection'
                ],
                related_cves=['CVE-2018-8414', 'CVE-2010-0188', 'CVE-2011-2462']
            ))

    def _analyze_file_structure(self):
        """Analyze overall file structure"""
        # Check file header
        header = self.file_data[:16]

        # Null byte analysis
        null_count = self.file_data.count(b'\x00')
        null_percentage = (null_count / len(self.file_data)) * 100

        if self.verbose:
            print(f"[*] Null bytes: {null_count:,} ({null_percentage:.2f}%)")

        # Elevated null bytes can indicate binary payloads
        if null_percentage > 1.5:
            self.indicators.append(ThreatIndicator(
                name='Elevated Null Bytes',
                severity='LOW',
                confidence=50,
                description=f'Null bytes: {null_percentage:.2f}% (unusual for text-based formats)',
                evidence=[
                    f'Null count: {null_count:,}',
                    f'Percentage: {null_percentage:.2f}%',
                    'May indicate binary payload'
                ],
                related_cves=[]
            ))

    def _analyze_pdf_structure(self):
        """PDF-specific structure analysis"""
        if self.verbose:
            print("[*] PDF file detected - performing PDF analysis")

        # Extract PDF version
        version_match = re.search(rb'%PDF-(\d+\.\d+)', self.file_data)
        if version_match:
            version = version_match.group(1).decode()
            if self.verbose:
                print(f"[*] PDF Version: {version}")

        # Count objects
        obj_pattern = rb'\d+ \d+ obj'
        objects = re.findall(obj_pattern, self.file_data)
        num_objects = len(objects)

        if self.verbose:
            print(f"[*] PDF Objects: {num_objects}")

        # Look for compressed streams
        stream_pattern = rb'stream\s*(.*?)\s*endstream'
        streams = re.findall(stream_pattern, self.file_data, re.DOTALL)
        compressed_streams = 0

        for stream in streams:
            # Check if FlateDecode compressed
            if b'FlateDecode' in stream or self._looks_compressed(stream):
                compressed_streams += 1

                # Check compression ratio (simplified)
                if len(stream) > 0:
                    # Estimate decompressed size (rough estimate)
                    ratio = len(stream) / max(len(stream) * 20, 1)  # Assume 20x expansion

                    if ratio < 0.10:  # Less than 10% compression
                        self.suspicious_compressions.append({
                            'compressed_size': len(stream),
                            'ratio_estimate': ratio * 100
                        })

        if self.verbose:
            print(f"[*] Compressed streams: {compressed_streams}")

        if self.suspicious_compressions:
            self.indicators.append(ThreatIndicator(
                name='Extreme Compression Ratios',
                severity='HIGH',
                confidence=75,
                description='PDF streams with extreme compression (typical of binary payloads)',
                evidence=[
                    f'Suspicious streams: {len(self.suspicious_compressions)}',
                    'Compression < 10% indicates binary/encrypted data',
                    'Matches CVE-2016-4265 pattern'
                ],
                related_cves=['CVE-2016-4265', 'CVE-2011-2462', 'CVE-2009-0658']
            ))

        # Look for suspicious PDF keywords
        suspicious_keywords = [
            b'/JavaScript', b'/JS', b'/AA', b'/OpenAction',
            b'/Launch', b'/EmbeddedFile', b'/AcroForm'
        ]

        found_keywords = []
        for keyword in suspicious_keywords:
            if keyword in self.file_data:
                found_keywords.append(keyword.decode())

        if found_keywords:
            self.indicators.append(ThreatIndicator(
                name='Suspicious PDF Keywords',
                severity='MEDIUM',
                confidence=65,
                description='PDF contains potentially malicious keywords',
                evidence=[f'Keywords: {", ".join(found_keywords)}'],
                related_cves=['CVE-2023-21608', 'CVE-2016-6957', 'CVE-2016-6958']
            ))

    def _extract_and_analyze_images(self):
        """Extract and analyze embedded images for steganography"""
        if not PIL_AVAILABLE:
            return

        # Look for JPEG markers
        jpeg_pattern = rb'\xff\xd8\xff'
        png_pattern = rb'\x89PNG\r\n\x1a\n'

        # Find JPEG images
        offset = 0
        image_count = 0

        while True:
            offset = self.file_data.find(jpeg_pattern, offset)
            if offset == -1:
                break

            # Find end of JPEG
            end_offset = self.file_data.find(b'\xff\xd9', offset)
            if end_offset != -1:
                image_data = self.file_data[offset:end_offset+2]
                image_count += 1

                # Analyze image for steganography
                self._analyze_image_lsb(image_data, image_count, 'JPEG', offset)

            offset += 1

        # Find PNG images
        offset = 0
        while True:
            offset = self.file_data.find(png_pattern, offset)
            if offset == -1:
                break

            # PNG end marker
            end_offset = self.file_data.find(b'IEND', offset)
            if end_offset != -1:
                image_data = self.file_data[offset:end_offset+8]
                image_count += 1

                self._analyze_image_lsb(image_data, image_count, 'PNG', offset)

            offset += 1

        if self.verbose and image_count > 0:
            print(f"[*] Found {image_count} embedded images")

    def _analyze_image_lsb(self, image_data: bytes, image_num: int, image_type: str, offset: int):
        """Analyze image for LSB steganography"""
        try:
            from io import BytesIO
            img = Image.open(BytesIO(image_data))

            # Convert to RGB if needed
            if img.mode != 'RGB':
                img = img.convert('RGB')

            # Get pixel data
            pixels = np.array(img)

            if len(pixels.shape) < 3:
                return

            # Extract LSB from each channel
            lsb_r = pixels[:, :, 0] & 1
            lsb_g = pixels[:, :, 1] & 1
            lsb_b = pixels[:, :, 2] & 1

            # Calculate LSB entropy
            entropy_r = self._calculate_lsb_entropy(lsb_r.flatten())
            entropy_g = self._calculate_lsb_entropy(lsb_g.flatten())
            entropy_b = self._calculate_lsb_entropy(lsb_b.flatten())

            if self.verbose:
                print(f"[*] Image {image_num} ({image_type}) LSB entropy:")
                print(f"    Red:   {entropy_r:.4f}")
                print(f"    Green: {entropy_g:.4f}")
                print(f"    Blue:  {entropy_b:.4f}")

            # High entropy in any channel indicates steganography
            max_entropy = max(entropy_r, entropy_g, entropy_b)
            if max_entropy > 0.45:  # Threshold from IWAR analysis
                # Extract LSB data
                lsb_bytes = self._extract_lsb_bytes(pixels)

                self.lsb_data.append({
                    'image_num': image_num,
                    'type': image_type,
                    'offset': offset,
                    'entropy_r': entropy_r,
                    'entropy_g': entropy_g,
                    'entropy_b': entropy_b,
                    'data': lsb_bytes[:1000]  # First 1000 bytes
                })

                self.indicators.append(ThreatIndicator(
                    name=f'LSB Steganography in Image {image_num}',
                    severity='CRITICAL',
                    confidence=95,
                    description=f'{image_type} image with high LSB entropy (hidden data carrier)',
                    evidence=[
                        f'Image type: {image_type}',
                        f'Offset: {offset:,} (0x{offset:x})',
                        f'Red channel entropy: {entropy_r:.4f}',
                        f'Green channel entropy: {entropy_g:.4f}',
                        f'Blue channel entropy: {entropy_b:.4f}',
                        f'Max entropy: {max_entropy:.4f} (threshold: 0.45)',
                        'Classic steganography carrier signature',
                        'Matches OceanLotus/APT32 TTP'
                    ],
                    related_cves=['CVE-2009-0927', 'CVE-2009-0658', 'CVE-2009-1858']
                ))

        except Exception as e:
            if self.verbose:
                print(f"[!] Image analysis error: {e}")

    def _calculate_lsb_entropy(self, lsb_bits) -> float:
        """Calculate entropy of LSB bits"""
        if not PIL_AVAILABLE:
            return 0.0
        if len(lsb_bits) == 0:
            return 0.0

        # Count 0s and 1s
        ones = np.sum(lsb_bits)
        zeros = len(lsb_bits) - ones

        if zeros == 0 or ones == 0:
            return 0.0

        # Calculate probability
        p1 = ones / len(lsb_bits)
        p0 = zeros / len(lsb_bits)

        # Shannon entropy
        entropy = -p0 * math.log2(p0) - p1 * math.log2(p1)

        return entropy

    def _extract_lsb_bytes(self, pixels) -> bytes:
        """Extract LSB data as bytes"""
        if not PIL_AVAILABLE:
            return b''
        # Flatten and get LSBs
        lsb_bits = (pixels.flatten() & 1).tolist()

        # Convert bits to bytes
        lsb_bytes = bytearray()
        for i in range(0, len(lsb_bits), 8):
            if i + 8 <= len(lsb_bits):
                byte = 0
                for j in range(8):
                    byte |= (lsb_bits[i + j] << (7 - j))
                lsb_bytes.append(byte)

        return bytes(lsb_bytes)

    def _calculate_chunk_entropy(self, data: bytes) -> float:
        """Calculate entropy for a chunk of data"""
        if len(data) == 0:
            return 0.0

        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1

        entropy = 0.0
        for count in byte_counts:
            if count > 0:
                probability = count / len(data)
                entropy -= probability * math.log2(probability)

        return entropy

    def _looks_compressed(self, data: bytes) -> bool:
        """Check if data looks compressed (high entropy)"""
        if len(data) < 100:
            return False

        entropy = self._calculate_chunk_entropy(data[:1000])
        return entropy > 7.0

    def _correlate_cves(self):
        """Correlate detected indicators with CVE database"""
        matched_cves = []

        # Check each indicator against CVE database
        for indicator in self.indicators:
            for cve_id in (indicator.related_cves or []):
                if cve_id in self.cve_database:
                    cve_info = self.cve_database[cve_id]
                    matched_cves.append({
                        'cve_id': cve_id,
                        'severity': cve_info['severity'],
                        'type': cve_info['type'],
                        'confidence': cve_info['confidence_match'],
                        'indicator': indicator.name
                    })

        if self.verbose and matched_cves:
            print(f"\n[*] CVE Correlation: {len(matched_cves)} matches")
            for match in matched_cves[:5]:
                print(f"    {match['cve_id']}: {match['type']} ({match['confidence']}% confidence)")

    def _attribute_malware_family(self):
        """Attempt to attribute to known malware families"""
        family_scores = {}

        # Initialize scores
        for family_name in self.malware_families:
            family_scores[family_name] = 0

        # Score based on indicators
        for indicator in self.indicators:
            # LSB steganography
            if 'LSB Steganography' in indicator.name:
                family_scores['OceanLotus/APT32'] += 30
                family_scores['IcedID/BokBot'] += 25

            # PE executables
            if 'PE Executable' in indicator.name:
                family_scores['DarkCloud Stealer'] += 25
                family_scores['Winos4.0'] += 20

            # High entropy
            if 'Entropy' in indicator.name:
                family_scores['OceanLotus/APT32'] += 20
                family_scores['IcedID/BokBot'] += 15

            # PDF malware
            if self.file_data[:4] == b'%PDF':
                family_scores['Epic Turla'] += 30
                family_scores['DarkCloud Stealer'] += 25
                family_scores['Winos4.0'] += 20

            # Multi-stage indicators
            if len(self.pe_candidates) > 1 and self.lsb_data:
                family_scores['OceanLotus/APT32'] += 35
                family_scores['Epic Turla'] += 30

        # Convert scores to confidence percentages
        max_score = 100
        for family_name, score in family_scores.items():
            if score > 0:
                confidence = min(score, 95)  # Cap at 95%

                family_info = self.malware_families[family_name]

                if confidence >= family_info['confidence_threshold']:
                    self.attributions.append(MalwareAttribution(
                        family_name=family_name,
                        confidence=confidence,
                        matching_ttps=family_info['ttps'][:3],  # Top 3 TTPs
                        description=f"{family_info['origin']}",
                        references=family_info['references']
                    ))

        # Sort by confidence
        self.attributions.sort(key=lambda x: x.confidence, reverse=True)

        if self.verbose and self.attributions:
            print(f"\n[*] Malware Family Attribution:")
            for attr in self.attributions[:3]:
                print(f"    {attr.family_name}: {attr.confidence}% confidence")

    def _generate_report(self) -> Dict[str, Any]:
        """Generate comprehensive analysis report"""
        # Calculate overall threat level
        threat_level = 'LOW'
        if any(i.severity == 'CRITICAL' for i in self.indicators):
            threat_level = 'CRITICAL'
        elif any(i.severity == 'HIGH' for i in self.indicators):
            threat_level = 'HIGH'
        elif any(i.severity == 'MEDIUM' for i in self.indicators):
            threat_level = 'MEDIUM'

        # Calculate file hash
        md5_hash = hashlib.md5(self.file_data).hexdigest()
        sha1_hash = hashlib.sha1(self.file_data).hexdigest()
        sha256_hash = hashlib.sha256(self.file_data).hexdigest()

        # Build report
        report = {
            'metadata': {
                'file_path': self.file_path,
                'file_size': len(self.file_data),
                'analysis_date': datetime.now().isoformat(),
                'analyzer_version': '1.0.0',
                'threat_level': threat_level
            },
            'file_hashes': {
                'md5': md5_hash,
                'sha1': sha1_hash,
                'sha256': sha256_hash
            },
            'entropy_analysis': {
                'file_entropy': self.file_entropy,
                'assessment': 'Encrypted/Compressed' if self.file_entropy > 7.5 else 'Normal'
            },
            'indicators': [
                {
                    'name': i.name,
                    'severity': i.severity,
                    'confidence': i.confidence,
                    'description': i.description,
                    'evidence': i.evidence,
                    'related_cves': i.related_cves or []
                }
                for i in self.indicators
            ],
            'pe_executables': [
                {
                    'offset': pe['offset'],
                    'entropy': pe['entropy'],
                    'pe_offset_ptr': pe['pe_offset_ptr']
                }
                for pe in self.pe_candidates
            ],
            'lsb_steganography': [
                {
                    'image_num': lsb['image_num'],
                    'type': lsb['type'],
                    'offset': lsb['offset'],
                    'entropy': {
                        'red': lsb['entropy_r'],
                        'green': lsb['entropy_g'],
                        'blue': lsb['entropy_b']
                    }
                }
                for lsb in self.lsb_data
            ],
            'base64_strings': {
                'count': len(self.base64_strings),
                'samples': [
                    {
                        'offset': b64['offset'],
                        'length': b64['length']
                    }
                    for b64 in self.base64_strings[:5]  # First 5
                ]
            },
            'malware_attribution': [
                {
                    'family': attr.family_name,
                    'confidence': attr.confidence,
                    'matching_ttps': attr.matching_ttps,
                    'description': attr.description,
                    'references': attr.references
                }
                for attr in self.attributions
            ],
            'summary': {
                'total_indicators': len(self.indicators),
                'critical_indicators': len([i for i in self.indicators if i.severity == 'CRITICAL']),
                'high_indicators': len([i for i in self.indicators if i.severity == 'HIGH']),
                'medium_indicators': len([i for i in self.indicators if i.severity == 'MEDIUM']),
                'low_indicators': len([i for i in self.indicators if i.severity == 'LOW']),
                'pe_candidates': len(self.pe_candidates),
                'lsb_images': len(self.lsb_data),
                'base64_strings': len(self.base64_strings),
                'attributions': len(self.attributions)
            }
        }

        return report

    def print_report(self, report: Dict[str, Any]):
        """Print formatted report to console"""
        print("\n" + "="*80)
        print("IWAR MALWARE ANALYSIS REPORT")
        print("="*80)

        print(f"\nFile: {report['metadata']['file_path']}")
        print(f"Size: {report['metadata']['file_size']:,} bytes")
        print(f"Threat Level: {report['metadata']['threat_level']}")
        print(f"Analysis Date: {report['metadata']['analysis_date']}")

        print("\n--- FILE HASHES ---")
        print(f"MD5:    {report['file_hashes']['md5']}")
        print(f"SHA1:   {report['file_hashes']['sha1']}")
        print(f"SHA256: {report['file_hashes']['sha256']}")

        print("\n--- ENTROPY ANALYSIS ---")
        print(f"File Entropy: {report['entropy_analysis']['file_entropy']:.4f} bits/byte")
        print(f"Assessment: {report['entropy_analysis']['assessment']}")

        if report['indicators']:
            print(f"\n--- THREAT INDICATORS ({len(report['indicators'])}) ---")
            for i, indicator in enumerate(report['indicators'], 1):
                print(f"\n{i}. {indicator['name']}")
                print(f"   Severity: {indicator['severity']} | Confidence: {indicator['confidence']}%")
                print(f"   Description: {indicator['description']}")
                if indicator['related_cves']:
                    print(f"   Related CVEs: {', '.join(indicator['related_cves'])}")

        if report['pe_executables']:
            print(f"\n--- EMBEDDED PE EXECUTABLES ({len(report['pe_executables'])}) ---")
            for i, pe in enumerate(report['pe_executables'], 1):
                print(f"\n{i}. Offset: 0x{pe['offset']:x} | Entropy: {pe['entropy']:.4f}")

        if report['lsb_steganography']:
            print(f"\n--- LSB STEGANOGRAPHY ({len(report['lsb_steganography'])}) ---")
            for lsb in report['lsb_steganography']:
                print(f"\nImage {lsb['image_num']} ({lsb['type']}):")
                print(f"  Red:   {lsb['entropy']['red']:.4f}")
                print(f"  Green: {lsb['entropy']['green']:.4f}")
                print(f"  Blue:  {lsb['entropy']['blue']:.4f}")

        if report['malware_attribution']:
            print(f"\n--- MALWARE FAMILY ATTRIBUTION ({len(report['malware_attribution'])}) ---")
            for attr in report['malware_attribution']:
                print(f"\n{attr['family']}: {attr['confidence']}% confidence")
                print(f"  Description: {attr['description']}")
                print(f"  Matching TTPs:")
                for ttp in attr['matching_ttps']:
                    print(f"    - {ttp}")

        print("\n--- SUMMARY ---")
        print(f"Total Indicators: {report['summary']['total_indicators']}")
        print(f"  CRITICAL: {report['summary']['critical_indicators']}")
        print(f"  HIGH:     {report['summary']['high_indicators']}")
        print(f"  MEDIUM:   {report['summary']['medium_indicators']}")
        print(f"  LOW:      {report['summary']['low_indicators']}")
        print(f"PE Candidates: {report['summary']['pe_candidates']}")
        print(f"LSB Images: {report['summary']['lsb_images']}")
        print(f"Base64 Strings: {report['summary']['base64_strings']}")

        print("\n" + "="*80)
        print("END OF REPORT")
        print("="*80 + "\n")

    def export_report(self, report: Dict[str, Any], output_path: str):
        """Export report to JSON file"""
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2)

        if self.verbose:
            print(f"[+] Report exported to: {output_path}")


def main():
    """Main entry point for standalone usage"""
    import argparse

    parser = argparse.ArgumentParser(
        description='IWAR Malware Analyzer - Blue Team PDF/Binary Analysis Tool'
    )
    parser.add_argument('file', help='File to analyze')
    parser.add_argument('-o', '--output', help='Output JSON report file')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('--no-images', action='store_true', help='Skip image analysis')

    args = parser.parse_args()

    # Create analyzer
    analyzer = IWARMalwareAnalyzer(verbose=args.verbose)

    try:
        # Analyze file
        print(f"\n[*] Starting analysis of: {args.file}")
        report = analyzer.analyze_file(args.file)

        # Print report
        analyzer.print_report(report)

        # Export if requested
        if args.output:
            analyzer.export_report(report, args.output)
            print(f"[+] Report saved to: {args.output}")

        # Exit code based on threat level
        threat_level = report['metadata']['threat_level']
        if threat_level == 'CRITICAL':
            return 2
        elif threat_level == 'HIGH':
            return 1
        else:
            return 0

    except Exception as e:
        print(f"\n[!] Error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
