#!/usr/bin/env python3
"""
VPS Server Configuration and Geolocation Manager for POLYGOTTEM
================================================================
Automates VPS server setup, IP geolocation management, and infrastructure
configuration across worldwide server deployments.

Features:
- Automated WireGuard/WARP configuration
- IP geolocation database management (WHOIS, Maxmind, IPInfo)
- BGP configuration generation (BIRD)
- Geofeed automation for bulk operations
- Multi-provider VPS management
- Geolocation verification across databases

Based on techniques from: https://blog.lyc8503.net/en/post/asn-5-worldwide-servers/

Author: SWORDIntel
Date: 2025-11-14
"""

import os
import sys
import json
import subprocess
import ipaddress
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

# Add tools to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from tui_helper import TUI, Colors
    from interactive_menu import InteractiveMenu
    from validation_utils import (
        validate_file_exists, ValidationError, FileOperationError,
        atomic_write, setup_logging
    )
    ENHANCEMENTS_AVAILABLE = True
except ImportError:
    ENHANCEMENTS_AVAILABLE = False
    TUI = None


class GeoProvider(Enum):
    """Geolocation database providers"""
    MAXMIND = "maxmind"
    IPINFO = "ipinfo"
    DB_IP = "db-ip"
    CLOUDFLARE = "cloudflare"
    IPLARK = "iplark"


class VPSProvider(Enum):
    """Supported VPS providers"""
    AWS = "aws"
    DIGITALOCEAN = "digitalocean"
    VULTR = "vultr"
    LINODE = "linode"
    HETZNER = "hetzner"
    OVH = "ovh"
    CUSTOM = "custom"


@dataclass
class VPSServer:
    """VPS server configuration"""
    hostname: str
    ip_address: str
    ipv6_address: Optional[str]
    country_code: str
    region: str
    provider: VPSProvider
    asn: Optional[str] = None
    credentials: Optional[Dict[str, str]] = None
    warp_enabled: bool = False
    bgp_configured: bool = False


@dataclass
class GeolocationConfig:
    """IP geolocation configuration"""
    subnet: str
    country_code: str
    region: str
    city: Optional[str] = None
    asn: Optional[str] = None
    description: str = "VPS Infrastructure"


class VPSGeoManager:
    """VPS server and geolocation configuration manager"""

    def __init__(self, verbose: bool = False):
        """
        Initialize VPS manager

        Args:
            verbose: Enable verbose logging
        """
        self.verbose = verbose
        self.logger = setup_logging(verbose=verbose, name='vps_manager') if ENHANCEMENTS_AVAILABLE else None
        self.tui = TUI() if TUI else None
        self.menu = InteractiveMenu(self.tui) if ENHANCEMENTS_AVAILABLE else None
        self.servers: List[VPSServer] = []

    def log(self, message: str, level: str = "info"):
        """Log message with TUI or standard output"""
        if self.tui:
            if level == "success":
                self.tui.success(message)
            elif level == "warning":
                self.tui.warning(message)
            elif level == "error":
                self.tui.error(message)
            else:
                self.tui.info(message)
        else:
            prefix = {
                "success": "[+]",
                "warning": "[!]",
                "error": "[!]",
                "info": "[*]"
            }.get(level, "[*]")
            print(f"{prefix} {message}")

    # ===== WIREGUARD/WARP CONFIGURATION =====

    def generate_warp_config(self, server: VPSServer, output_path: Optional[str] = None) -> str:
        """
        Generate WireGuard/WARP configuration for VPS

        Args:
            server: VPS server configuration
            output_path: Path to save config (default: auto-generate)

        Returns:
            Path to generated config file
        """
        self.log(f"Generating WARP config for {server.hostname}...")

        if output_path is None:
            output_path = f"warp_{server.hostname}.conf"

        # WireGuard configuration template
        config = f"""# WireGuard/WARP Configuration for {server.hostname}
# Generated by POLYGOTTEM VPS Manager
# Country: {server.country_code}, Region: {server.region}

[Interface]
PrivateKey = <REPLACE_WITH_PRIVATE_KEY>
Address = {server.ip_address}/32
"""

        if server.ipv6_address:
            config += f"Address = {server.ipv6_address}/128\n"

        # Add routing rules for geolocation
        config += f"""DNS = 1.1.1.1, 1.0.0.1
MTU = 1280

# Route configuration to maintain geolocation
PostUp = ip -4 rule add from {server.ip_address} lookup main
PostDown = ip -4 rule delete from {server.ip_address} lookup main
"""

        if server.ipv6_address:
            config += f"""PostUp = ip -6 rule add from {server.ipv6_address} lookup main
PostDown = ip -6 rule delete from {server.ipv6_address} lookup main
"""

        config += f"""
[Peer]
PublicKey = <REPLACE_WITH_CLOUDFLARE_PUBLIC_KEY>
AllowedIPs = 0.0.0.0/0
"""

        if server.ipv6_address:
            config += "AllowedIPs = ::/0\n"
            config += f"Endpoint = [{server.ipv6_address}]:2408\n"
        else:
            config += f"Endpoint = {server.ip_address}:2408\n"

        config += "PersistentKeepalive = 25\n"

        try:
            atomic_write(output_path, config, mode='w') if ENHANCEMENTS_AVAILABLE else open(output_path, 'w').write(config)
            self.log(f"WARP config saved: {output_path}", "success")
            return output_path
        except Exception as e:
            self.log(f"Failed to write config: {e}", "error")
            raise

    def install_warp(self, server: VPSServer) -> bool:
        """
        Generate installation script for WARP on VPS

        Args:
            server: VPS server configuration

        Returns:
            True if script generated successfully
        """
        self.log(f"Generating WARP installation script for {server.hostname}...")

        install_script = f"""#!/bin/bash
# WARP Installation Script for {server.hostname}
# Generated by POLYGOTTEM VPS Manager

set -e

echo "[*] Installing WireGuard..."
if command -v apt-get &> /dev/null; then
    apt-get update
    apt-get install -y wireguard wireguard-tools
elif command -v yum &> /dev/null; then
    yum install -y epel-release elrepo-release
    yum install -y kmod-wireguard wireguard-tools
elif command -v pacman &> /dev/null; then
    pacman -S --noconfirm wireguard-tools
else
    echo "[!] Unsupported package manager"
    exit 1
fi

echo "[+] WireGuard installed successfully"

# Enable IP forwarding for geolocation routing
echo "[*] Configuring IP forwarding..."
echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
echo "net.ipv6.conf.all.forwarding = 1" >> /etc/sysctl.conf
sysctl -p

echo "[*] Setting up WARP configuration..."
mkdir -p /etc/wireguard
cat > /etc/wireguard/wg0.conf << 'EOF'
# Configuration will be generated separately
# Copy warp_{server.hostname}.conf here after generating keys
EOF

echo "[+] WARP setup complete"
echo "[*] Next steps:"
echo "    1. Generate WireGuard keys: wg genkey | tee privatekey | wg pubkey > publickey"
echo "    2. Update wg0.conf with your keys"
echo "    3. Start WARP: wg-quick up wg0"
echo "    4. Enable on boot: systemctl enable wg-quick@wg0"
"""

        script_path = f"install_warp_{server.hostname}.sh"
        try:
            atomic_write(script_path, install_script, mode='w') if ENHANCEMENTS_AVAILABLE else open(script_path, 'w').write(install_script)
            os.chmod(script_path, 0o755)
            self.log(f"Installation script saved: {script_path}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to generate script: {e}", "error")
            return False

    # ===== WHOIS/RIPE DATABASE CONFIGURATION =====

    def generate_ripe_inet6num(self, geo_config: GeolocationConfig) -> str:
        """
        Generate RIPE inet6num object for WHOIS database

        Args:
            geo_config: Geolocation configuration

        Returns:
            RIPE database object text
        """
        self.log(f"Generating RIPE inet6num for {geo_config.subnet}...")

        # Validate subnet
        try:
            network = ipaddress.ip_network(geo_config.subnet)
            if network.version != 6:
                raise ValueError("RIPE inet6num requires IPv6 subnet")
            if network.prefixlen > 48:
                self.log("Warning: RIPE recommends minimum /48 for inet6num", "warning")
        except ValueError as e:
            raise ValidationError(f"Invalid subnet: {e}")

        ripe_object = f"""# RIPE Database Object for {geo_config.subnet}
# Generated by POLYGOTTEM VPS Manager

inet6num:       {geo_config.subnet}
netname:        {geo_config.description.upper().replace(' ', '-')}
country:        {geo_config.country_code.upper()}
admin-c:        <REPLACE_WITH_ADMIN_CONTACT>
tech-c:         <REPLACE_WITH_TECH_CONTACT>
status:         ASSIGNED
mnt-by:         <REPLACE_WITH_MAINTAINER>
created:        {self._get_timestamp()}
last-modified:  {self._get_timestamp()}
source:         RIPE
remarks:        Geolocation: {geo_config.region}
"""

        if geo_config.city:
            ripe_object += f"remarks:        City: {geo_config.city}\n"

        if geo_config.asn:
            ripe_object += f"remarks:        ASN: AS{geo_config.asn}\n"

        return ripe_object

    def _get_timestamp(self) -> str:
        """Get current timestamp in RIPE format"""
        from datetime import datetime
        return datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

    # ===== BGP CONFIGURATION (BIRD) =====

    def generate_bird_config(self, server: VPSServer, peer_asn: str, peer_ip: str) -> str:
        """
        Generate BIRD BGP configuration

        Args:
            server: VPS server configuration
            peer_asn: Peer ASN number
            peer_ip: Peer IP address

        Returns:
            BIRD configuration text
        """
        self.log(f"Generating BIRD config for {server.hostname}...")

        if not server.asn:
            raise ValueError("Server ASN not configured")

        bird_config = f"""# BIRD BGP Configuration for {server.hostname}
# Generated by POLYGOTTEM VPS Manager

log syslog all;

router id {server.ip_address};

protocol device {{
}}

protocol static {{
    ipv6;
    route {server.ipv6_address if server.ipv6_address else '::/0'} reject;
}}

protocol bgp peer_{peer_asn} {{
    local as {server.asn};
    neighbor {peer_ip} as {peer_asn};

    ipv6 {{
        import none;
        export where proto = "static";
    }};
}}

# Geolocation routing
protocol kernel {{
    ipv6 {{
        export all;
    }};
}}
"""

        return bird_config

    # ===== GEOFEED GENERATION =====

    def generate_geofeed(self, geo_configs: List[GeolocationConfig], output_path: str = "geofeed.csv") -> str:
        """
        Generate geofeed CSV for bulk geolocation updates

        Args:
            geo_configs: List of geolocation configurations
            output_path: Path to save geofeed CSV

        Returns:
            Path to generated geofeed file
        """
        self.log(f"Generating geofeed for {len(geo_configs)} subnets...")

        # Geofeed CSV format: subnet,country,region,city,postal_code
        geofeed_lines = ["# Geofeed generated by POLYGOTTEM VPS Manager"]
        geofeed_lines.append("# Format: subnet,country,region,city,postal_code")
        geofeed_lines.append("")

        for config in geo_configs:
            city = config.city if config.city else ""
            line = f"{config.subnet},{config.country_code},{config.region},{city},"
            geofeed_lines.append(line)

        geofeed_content = "\n".join(geofeed_lines)

        try:
            atomic_write(output_path, geofeed_content, mode='w') if ENHANCEMENTS_AVAILABLE else open(output_path, 'w').write(geofeed_content)
            self.log(f"Geofeed saved: {output_path}", "success")
            return output_path
        except Exception as e:
            self.log(f"Failed to write geofeed: {e}", "error")
            raise

    # ===== GEOLOCATION VERIFICATION =====

    def generate_verification_script(self, servers: List[VPSServer], output_path: str = "verify_geo.sh") -> str:
        """
        Generate bash script to verify geolocation across databases

        Args:
            servers: List of VPS servers to verify
            output_path: Path to save verification script

        Returns:
            Path to generated script
        """
        self.log(f"Generating verification script for {len(servers)} servers...")

        script = """#!/bin/bash
# Geolocation Verification Script
# Generated by POLYGOTTEM VPS Manager

set -e

echo "==================================="
echo "  Geolocation Verification"
echo "==================================="
echo ""

# Function to check IP geolocation
check_geo() {
    local ip=$1
    local hostname=$2

    echo "Checking $hostname ($ip)..."
    echo "-----------------------------------"

    # Cloudflare trace
    echo "Cloudflare:"
    curl -s "https://1.1.1.1/cdn-cgi/trace" --resolve "1.1.1.1:443:$ip" | grep -E "(ip|loc|colo)"
    echo ""

    # IPInfo
    echo "IPInfo.io:"
    curl -s "https://ipinfo.io/$ip/json" | jq -r '.country, .region, .city' 2>/dev/null || echo "Failed"
    echo ""

    # IP-API
    echo "IP-API:"
    curl -s "http://ip-api.com/json/$ip?fields=country,regionName,city,status" | jq -r '.country, .regionName, .city' 2>/dev/null || echo "Failed"
    echo ""

    echo "-----------------------------------"
    echo ""
}

"""

        for server in servers:
            script += f'check_geo "{server.ip_address}" "{server.hostname}"\n'

        script += """
echo "==================================="
echo "  Verification Complete"
echo "==================================="
echo ""
echo "Note: Database updates take 3 days to 2 weeks"
echo "Cloudflare lags Maxmind by 1-2 additional weeks"
"""

        try:
            atomic_write(output_path, script, mode='w') if ENHANCEMENTS_AVAILABLE else open(output_path, 'w').write(script)
            os.chmod(output_path, 0o755)
            self.log(f"Verification script saved: {output_path}", "success")
            return output_path
        except Exception as e:
            self.log(f"Failed to generate script: {e}", "error")
            raise

    # ===== SERVER CONFIGURATION EXPORT =====

    def export_server_configs(self, output_dir: str = "vps_configs") -> Dict[str, List[str]]:
        """
        Export all configuration files for managed servers

        Args:
            output_dir: Directory to save configurations

        Returns:
            Dictionary mapping server hostnames to generated file lists
        """
        self.log(f"Exporting configurations for {len(self.servers)} servers...")

        os.makedirs(output_dir, exist_ok=True)
        results = {}

        for server in self.servers:
            files = []
            server_dir = Path(output_dir) / server.hostname
            server_dir.mkdir(exist_ok=True)

            # WARP config
            warp_config = self.generate_warp_config(server, str(server_dir / "warp.conf"))
            files.append(warp_config)

            # Installation script
            if self.install_warp(server):
                files.append(f"install_warp_{server.hostname}.sh")

            # Geolocation config
            geo_config = GeolocationConfig(
                subnet=server.ipv6_address if server.ipv6_address else server.ip_address,
                country_code=server.country_code,
                region=server.region,
                asn=server.asn
            )

            # RIPE object
            ripe_obj = self.generate_ripe_inet6num(geo_config)
            ripe_path = server_dir / "ripe_inet6num.txt"
            atomic_write(str(ripe_path), ripe_obj, mode='w') if ENHANCEMENTS_AVAILABLE else open(ripe_path, 'w').write(ripe_obj)
            files.append(str(ripe_path))

            results[server.hostname] = files

        # Generate geofeed for all servers
        geo_configs = [
            GeolocationConfig(
                subnet=s.ipv6_address if s.ipv6_address else s.ip_address,
                country_code=s.country_code,
                region=s.region,
                asn=s.asn
            ) for s in self.servers
        ]
        geofeed_path = self.generate_geofeed(geo_configs, str(Path(output_dir) / "geofeed.csv"))

        # Generate verification script
        verify_path = self.generate_verification_script(self.servers, str(Path(output_dir) / "verify_geo.sh"))

        self.log(f"All configurations exported to {output_dir}", "success")
        return results

    # ===== INTERACTIVE SERVER MANAGEMENT =====

    def interactive_add_server(self):
        """Interactively add a VPS server"""
        if not self.menu:
            print("[!] Interactive mode requires enhancements")
            return

        self.tui.header("Add VPS Server")

        # Get hostname
        hostname = self.menu.prompt_input("Hostname", default="vps-server-01")

        # Get IP addresses
        ip_address = self.menu.prompt_input("IPv4 Address", default="1.2.3.4")
        ipv6_address = self.menu.prompt_input("IPv6 Address (optional)", default="")
        if not ipv6_address:
            ipv6_address = None

        # Get location
        country_code = self.menu.prompt_input("Country Code (2 letters)", default="US")
        region = self.menu.prompt_input("Region/State", default="California")

        # Select provider
        provider_options = [
            {'label': p.name, 'description': p.value, 'value': p}
            for p in VPSProvider
        ]
        provider_idx = self.menu.single_select("VPS Provider", provider_options)
        provider = provider_options[provider_idx]['value'] if provider_idx is not None else VPSProvider.CUSTOM

        # Get ASN
        asn = self.menu.prompt_input("ASN (optional)", default="")
        if not asn:
            asn = None

        # Create server
        server = VPSServer(
            hostname=hostname,
            ip_address=ip_address,
            ipv6_address=ipv6_address,
            country_code=country_code.upper(),
            region=region,
            provider=provider,
            asn=asn
        )

        self.servers.append(server)
        self.log(f"Server {hostname} added successfully", "success")

    def run_interactive(self):
        """Run interactive VPS management"""
        if not self.menu:
            print("[!] Interactive mode requires enhancements")
            return

        self.tui.banner("VPS Geolocation Manager", "Worldwide Server Configuration")

        while True:
            options = [
                {'label': '‚ûï Add VPS Server', 'description': 'Add new server configuration', 'value': 'add'},
                {'label': 'üìã List Servers', 'description': f'View {len(self.servers)} configured servers', 'value': 'list'},
                {'label': 'üì§ Export Configs', 'description': 'Generate all configuration files', 'value': 'export'},
                {'label': '‚úÖ Verify Geolocation', 'description': 'Check IP geolocation databases', 'value': 'verify'},
                {'label': '‚ùå Exit', 'description': 'Exit manager', 'value': 'exit'},
            ]

            choice_idx = self.menu.single_select("VPS Management Menu", options)
            if choice_idx is None or options[choice_idx]['value'] == 'exit':
                break

            action = options[choice_idx]['value']

            if action == 'add':
                self.interactive_add_server()
            elif action == 'list':
                self._list_servers()
            elif action == 'export':
                output_dir = self.menu.prompt_input("Output directory", default="vps_configs")
                self.export_server_configs(output_dir)
            elif action == 'verify':
                if self.servers:
                    self.generate_verification_script(self.servers)
                    self.log("Run ./verify_geo.sh to check geolocation", "info")
                else:
                    self.log("No servers configured", "warning")

    def _list_servers(self):
        """List configured servers"""
        if not self.servers:
            self.log("No servers configured", "warning")
            return

        self.tui.header("Configured Servers")
        for i, server in enumerate(self.servers, 1):
            self.tui.info(f"{i}. {server.hostname}")
            self.tui.list_item(f"IP: {server.ip_address}", level=1)
            if server.ipv6_address:
                self.tui.list_item(f"IPv6: {server.ipv6_address}", level=1)
            self.tui.list_item(f"Location: {server.country_code}, {server.region}", level=1)
            self.tui.list_item(f"Provider: {server.provider.value}", level=1)
            if server.asn:
                self.tui.list_item(f"ASN: AS{server.asn}", level=1)
            print()


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description="VPS Geolocation Manager - Worldwide Server Configuration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive mode
  python vps_geo_manager.py --interactive

  # Generate single server config
  python vps_geo_manager.py --generate-warp --ip 1.2.3.4 --country US

  # Export all configurations
  python vps_geo_manager.py --export-configs --output ./configs

Features:
  - WireGuard/WARP configuration generation
  - RIPE WHOIS database objects
  - BGP configuration (BIRD)
  - Geofeed CSV for bulk updates
  - Multi-database geolocation verification
  - Automated server deployment scripts

Based on techniques from:
  https://blog.lyc8503.net/en/post/asn-5-worldwide-servers/
        """
    )

    parser.add_argument('-i', '--interactive', action='store_true',
                       help='Run in interactive mode')
    parser.add_argument('--generate-warp', action='store_true',
                       help='Generate WARP configuration')
    parser.add_argument('--export-configs', action='store_true',
                       help='Export all server configurations')
    parser.add_argument('--ip', type=str,
                       help='Server IP address')
    parser.add_argument('--country', type=str,
                       help='Country code (2 letters)')
    parser.add_argument('--region', type=str,
                       help='Region/state name')
    parser.add_argument('--output', type=str, default='vps_configs',
                       help='Output directory for configurations')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Enable verbose logging')

    args = parser.parse_args()

    manager = VPSGeoManager(verbose=args.verbose)

    try:
        if args.interactive:
            manager.run_interactive()
        elif args.generate_warp:
            if not args.ip or not args.country:
                print("[!] Error: --ip and --country required for WARP config")
                return 1

            server = VPSServer(
                hostname=f"vps-{args.country.lower()}",
                ip_address=args.ip,
                ipv6_address=None,
                country_code=args.country.upper(),
                region=args.region or args.country,
                provider=VPSProvider.CUSTOM
            )
            manager.generate_warp_config(server)
            manager.install_warp(server)
        elif args.export_configs:
            if not manager.servers:
                print("[!] No servers configured. Use --interactive to add servers.")
                return 1
            manager.export_server_configs(args.output)
        else:
            parser.print_help()
            return 0

        return 0

    except KeyboardInterrupt:
        print("\n\n[!] Interrupted by user")
        return 130
    except Exception as e:
        print(f"\n[!] Error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
